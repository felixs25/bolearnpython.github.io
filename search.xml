<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scrapy]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fscrapy.html</url>
    <content type="text"><![CDATA[cmdscrapy startproject project cd project/project/spiders scrapy genspider -t crawl spider1 spider1.com scrapy crawl myspider -s LOG_FILE=scrapy.log scrapy shell &lt;url&gt; scrapy check -l scrapy list scrapy edit &lt;spider&gt; scrapy view &lt;url&gt; scrapy parse &lt;url&gt; [options] --spider=SPIDER: 跳过自动检测spider并强制使用特定的spider --a NAME=VALUE: 设置spider的参数(可能被重复) --callback or -c: spider中用于解析返回(response)的回调函数 --pipelines: 在pipeline中处理item --rules or -r: 使用 CrawlSpider 规则来发现用来解析返回(response)的回调函数 --noitems: 不显示爬取到的item --nolinks: 不显示提取到的链接 --nocolour: 避免使用pygments对输出着色 --depth or -d: 指定跟进链接请求的层次数(默认: 1) --verbose or -v: 显示每个请求的详细信息 scrapy settings --get DOWNLOAD_DELAY scrapy runspider myspider.py scrapy bench response-requestFormRequest(url=&apos;http://www.viajanet.com.br/busca/resources/api/AvailabilityStatusAsync&apos;,formdata={}) request.meta[&apos;proxy&apos;] = &quot;http://{}:{}@{}:{}&quot;.format(user,pass,&apos;127.0.0.1&apos;,&apos;8118&apos;) meta = {&apos;dont_redirect&apos;: True,&apos;handle_httpstatus_list&apos;: [301,302]} dont_redirect dont_filter priority #此请求的优先级 dont_retry handle_httpstatus_list dont_merge_cookies cookiejar redirect_urls bindaddress dont_obey_robotstxt download_timeout LinkExtractor123456789101112131415161718192021LinkExtractor(allow=(), deny=(), allow_domains=(), deny_domains=(), restrict_xpaths=(), tags=(&apos;a&apos;, &apos;area&apos;), attrs=(&apos;href&apos;,), canonicalize=False, unique=True, process_value=None, deny_extensions=None, restrict_css=(), strip=True)allow (a regular expression (or list of)) – 必须要匹配这个正则表达式(或正则表达式列表)的URL才会被提取｡如果没有给出(或为空), 它会匹配所有的链接｡deny (a regular expression (or list of)) – 与这个正则表达式(或正则表达式列表)的(绝对)不匹配的URL必须被排除在外(即不提取)｡它的优先级高于 allow 的参数｡如果没有给出(或None), 将不排除任何链接｡allow_domains (str or list) – 单值或者包含字符串域的列表表示会被提取的链接的domains｡deny_domains (str or list) – 单值或包含域名的字符串,将不考虑提取链接的domains｡deny_extensions (list) – 应提取链接时,可以忽略扩展名的列表｡如果没有给出, 它会默认为 scrapy.linkextractor 模块中定义的 IGNORED_EXTENSIONS 列表｡restrict_xpaths (str or list) – 一个的XPath (或XPath的列表),它定义了链路应该从提取的响应内的区域｡如果给定的,只有那些XPath的选择的文本将被扫描的链接｡见下面的例子｡tags (str or list) – 提取链接时要考虑的标记或标记列表｡默认为 ( &apos;a&apos; , &apos;area&apos;) ｡attrs (list) – 提取链接时应该寻找的attrbitues列表(仅在 tag 参数中指定的标签)｡默认为 (&apos;href&apos;)｡canonicalize (boolean) – 规范化每次提取的URL(使用scrapy.utils.url.canonicalize_url )｡默认为 True ｡unique (boolean) – 重复过滤是否应适用于提取的链接｡process_value (callable) – 它接收来自扫描标签和属性提取每个值, 可以修改该值, 并返回一个新的, 或返回 None 完全忽略链接的功能｡如果没有给出, process_value 默认是 lambda x: xdef process_value(value): m = re.search(&quot;javascript:goToPage\(&apos;(.*?)&apos;&quot;, value) if m: return m.group(1)Rule(link_extractor, callback=None, cb_kwargs=None, follow=None, process_links=None, process_request=None)cb_kwargs 包含传递给回调函数的参数(keyword argument)的字典。follow 是一个布尔(boolean)值，指定了根据该规则从response提取的链接是否需要跟进。 如果 callback 为None， follow 默认设置为 True ，否则默认为 False 。process_links 是一个callable或string(该spider中同名的函数将会被调用)。 从link_extractor中获取到链接列表时将会调用该函数。该方法主要用来过滤。process_request 是一个callable或string(该spider中同名的函数将会被调用)。 该规则提取到每个request时都会调用该函数。该函数必须返回一个request或者None。 (用来过滤request) 内存使用扩展(Memory usage extension)MEMDEBUG_ENABLED=False 是否启用内存调试(memory debugging) MEMDEBUG_NOTIFY=[] 如果该设置不为空like:[&apos;user@example.com&apos;]，当启用内存调试时将会发送一份内存报告到指定的地址；否则该报告将写到log中 MEMUSAGE_LIMIT_MB=0 在关闭Scrapy之前所允许的最大内存数 MEMUSAGE_REPORT=False 每个spider被关闭时是否发送内存使用报告。 MEMUSAGE_WARNING_MB=0 在发送警告email前所允许的最大内存数 关闭spider扩展CLOSESPIDER_TIMEOUT = 82800 CLOSESPIDER_ITEMCOUNT CLOSESPIDER_PAGECOUNT CLOSESPIDER_ERRORCOUNT ## 关闭spiderscrapy.exceptions.CloseSpider(reason=&apos;cancelled&apos;) def parse_page(self, response): if &apos;Bandwidth exceeded&apos; in response.body: raise CloseSpider(&apos;bandwidth_exceeded&apos;) 邮件from scrapy.mail import MailSender mailer = MailSender() 或 mailer = MailSender.from_settings(settings) 发送emailmailer.send(to=[&quot;someone@example.com&quot;], subject=&quot;Some subject&quot;, body=&quot;Some body&quot;, cc=[&quot;another@example.com&quot;]) MAIL_FROM=&apos;scrapy@localhost&apos; 用于发送email的地址(address)(填入 ``From:``) 。 MAIL_HOST=&apos;localhost&apos; 发用邮件的SMTP主机 MAIL_PORT=25 发用邮件的SMTP端口 MAIL_USER=None MAIL_PASS=None 用于SMTP认证，与 :setting:`MAIL_USER` 配套的密码。 MAIL_TLS=False 强制使用STARTTLS。STARTTLS能使得在已经存在的不安全连接上，通过使用SSL/TLS来实现安全连接。 MAIL_SSL=False 强制使用SSL加密连接。 单spider追踪多cookie sessionfor i, url in enumerate(urls): yield scrapy.Request(&quot;http://www.example.com&quot;, meta={&apos;cookiejar&apos;: i}, callback=self.parse_page) def parse_page(self, response): return scrapy.Request(&quot;http://www.example.com/otherpage&quot;, meta={&apos;cookiejar&apos;: response.meta[&apos;cookiejar&apos;]}, callback=self.parse_other_page) 设置缓存Dummy策略(默认值) RFC2616策略 HTTPCACHE_ENABLED = False HTTPCACHE_DIR = &apos;httpcache&apos; HTTPCACHE_IGNORE_MISSING = False HTTPCACHE_STORAGE = &apos;scrapy.extensions.httpcache.FilesystemCacheStorage&apos; HTTPCACHE_EXPIRATION_SECS = 0 HTTPCACHE_ALWAYS_STORE = False HTTPCACHE_IGNORE_HTTP_CODES = [] HTTPCACHE_IGNORE_SCHEMES = [&apos;file&apos;] HTTPCACHE_IGNORE_RESPONSE_CACHE_CONTROLS = [] HTTPCACHE_DBM_MODULE = &apos;anydbm&apos; if six.PY2 else &apos;dbm&apos; HTTPCACHE_POLICY = &apos;scrapy.extensions.httpcache.DummyPolicy&apos; HTTPCACHE_GZIP = False 增加全局并发数::CONCURRENT_REQUESTS = 100 Item Processor(即 Item Pipeline) 同时处理(每个response的)item的最大值。 CONCURRENT_ITEMS = 100 Scrapy downloader 并发请求(concurrent requests)的最大值。 CONCURRENT_REQUESTS = 16 对单个网站进行并发请求的最大值。 CONCURRENT_REQUESTS_PER_DOMAIN = 8 对单个IP进行并发请求的最大值。如果非0，则忽略 CONCURRENT_REQUESTS_PER_DOMAIN 设定， 使用该设定。 也就是说，并发限制将针对IP，而不是网站。 该设定也影响 DOWNLOAD_DELAY: 如果 CONCURRENT_REQUESTS_PER_IP 非0，下载延迟应用在IP而不是网站上。 CONCURRENT_REQUESTS_PER_IP = 0 设置Log级别:LOG_ENABLED = true LOG_ENCODING = &quot;utf-8&quot; LOG_FILE = &quot;log/spider.log&quot; LOG_FORMAT = &quot;%(asctime)s [%(name)s] %(levelname)s: %(message)s&quot; LOG_DATEFORMAT = &quot;%Y-%m-%d %H:%M:%S&quot; LOG_LEVEL = &apos;INFO&apos;#默认&apos;debug&apos; LOG_ENCODING#logging使用的编码 LOG_STDOUT #为 ``True``,进程所有的标准输出(及错误)将会被重定向到log中 #spider self.logger.info(&apos;Parse function called on %s&apos;, response.url) 自定义logger import logging logger = logging.getLogger(&apos;zhangsan&apos;) logger.info(&apos;Parse function called on %s&apos;, response.url) 禁止cookies::COOKIES_ENABLED = False COOKIES_DEBUG timeoutDOWNLOAD_TIMEOUT = 10 # 3mins robotsROBOTSTXT_OBEY = False 爬取URL的最大长度URLLENGTH_LIMIT = 2083 禁止重试::RETRY_ENABLED = False RETRY_TIMES=2 RETRY_HTTP_CODES=[500, 502, 503, 504, 400, 408] [500, 503, 504, 400, 403, 404, 408] 关闭重定向::REDIRECT_ENABLED = False REDIRECT_MAX_TIMES=20 单个request被重定向的最大次数。 REDIRECT_MAX_METAREFRESH_DELAY=100 有些网站使用 meta-refresh 重定向到session超时页面， 因此我们限制自动重定向到最大延迟(秒)。 REDIRECT_PRIORITY_ADJUST 默认: ``+2`` 修改重定向请求相对于原始请求的优先级。 负数意味着更多优先级。 自动限速AUTOTHROTTLE_ENABLED=False AUTOTHROTTLE_START_DELAY=5.0 AUTOTHROTTLE_MAX_DELAY=60 AUTOTHROTTLE_DEBUG=False depth防止死循环爬取网站最大允许的深度(depth)值。如果为0，则没有限制。 DEPTH_LIMIT = 0 整数值。用于根据深度调整request优先级。 如果为0，则不根据深度进行优先级调整。 DEPTH_PRIORITY = 0 广度优先顺序DEPTH_PRIORITY = 1 SCHEDULER_DISK_QUEUE = &apos;scrapy.squeue.PickleFifoDiskQueue&apos; SCHEDULER_MEMORY_QUEUE = &apos;scrapy.squeue.FifoMemoryQueue&apos; errorHTTPERROR_ALLOWED_CODES=[] 忽略该列表中所有非200状态码的response。 HTTPERROR_ALLOW_ALL=Flase 忽略所有response，不管其状态值。 telnetTELNETCONSOLE_ENABLED=True telnet 终端是否启用。 TELNETCONSOLE_PORT 默认: ``[6023, 6073]`` EDITOR默认: depends on the environment 执行 edit 命令编辑spider时使用的编辑器。 其默认为 EDITOR 环境变量。如果该变量未设置，其默认为 vi (Unix系统) 或者 IDLE编辑器(Windows)。 其他1234567891011121314151617181920212223242526272829303132333435USER_AGENT = &apos;Scrapy/&apos;DEFAULT_REQUEST_HEADERS = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;en&apos;,&#125;ITEM_PIPELINES = &#123; &apos;mybot.pipelines.validate.ValidateMyItem&apos;: 300, &apos;mybot.pipelines.validate.StoreMyItem&apos;: 800,&#125;将原先的配置进行覆盖class MySpider(scrapy.Spider): name = &apos;myspider&apos; custom_settings = &#123; &apos;DOWNLOAD_DELAY&apos;: 1, &apos;RANDOMIZE_DOWNLOAD_DELAY&apos;: False, &apos;CONCURRENT_REQUESTS_PER_IP&apos;: 1, &#125;class MyExtension(object): @classmethod def from_crawler(cls, crawler): settings = crawler.settings if settings[&apos;LOG_ENABLED&apos;]: print &quot;log is enabled!&quot;DNSCACHE_ENABLED默认: ``True``DUPEFILTER_CLASS默认: ``&apos;scrapy.dupefilter.RFPDupeFilter&apos;``DUPEFILTER_DEBUG默认: ``False``SCHEDULER默认: ``&apos;scrapy.core.scheduler.Scheduler&apos;`` scrapydpip install scrapyd-client 拷贝scrapyd-deploy工具到爬虫目录下 Ubuntu/Windows: [deploy:tutorial_deploy] url = http://192.168.17.129:6800/ project = tutorial username = enlong password = test Windows: python c:\Python27\Scripts\scrapyd-deploy Ubuntu: scrapyd-deploy tutorial_deploy -p tutorial python scrapyd-deploy -l scrapyd-deploy &lt;target&gt; -p &lt;project&gt; --version &lt;version&gt; python scrapyd-deploy 127 -p projectccp --version ver20160702 1、获取状态 http://127.0.0.1:6800/daemonstatus.json 2、获取项目列表 http://127.0.0.1:6800/listprojects.json 3、获取项目下已发布的爬虫列表 http://127.0.0.1:6800/listspiders.json?project=myproject 4、获取项目下已发布的爬虫版本列表 http://127.0.0.1:6800/listversions.json?project=myproject 5、获取爬虫运行状态 http://127.0.0.1:6800/listjobs.json?project=myproject 6、启动服务器上某一爬虫（必须是已发布到服务器的爬虫） http://localhost:6800/schedule.json （post方式，data={&quot;project&quot;:myproject,&quot;spider&quot;:myspider}） 7、删除某一版本爬虫 http://127.0.0.1:6800/delversion.json （post方式，data={&quot;project&quot;:myproject,&quot;version&quot;:myversion}） 8、删除某一工程，包括该工程下的各版本爬虫 http://127.0.0.1:6800/delproject.json（post方式，data={&quot;project&quot;:myproject}） 错误TypeError 表现形式:TypeError: ‘float’ object is not iterable 相关搜索:https://github.com/scrapy/scrapy/issues/2461 解决方法:sudo pip install -U Twisted==16.6.0 ERROR: Unable to read the instance data ,giving up 表现形式: 直接error 报错，拿不到数据 相关搜索: 无 解决方法: 回调函数中，必须返回 Request 对象 或者Item对象 ，可以直接返回这种类型的数据就可以了 Library not loaded: /opt/local/lib/libssl.1.0.0.dylib (LoadError) 解决方法: brew remove openssl 先卸载，然后 brew install openssl unknown command: crawl error 表现形式: 无法使用crawl 命令 相关搜索 : unknown-command-crawl-error 解决方法 : 切换到有scrapy.cfg文件下，然后使用命令]]></content>
      <tags>
        <tag>scrapy,设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fselenium.html</url>
    <content type="text"><![CDATA[selenium–隐式等待12345678driver.implicitly_wait(5)driver.save_screenshot(&apos;e:\screenshot.png&apos;)driver.set_page_load_timeout(10)driver.set_script_timeout(10)text = driver.page_sourceCOOKIES_ENABLES = Falsedriver.close()driver.quit() –多层框架或窗口的定位：12345678910switch_to_frame()switch_to_window()driver.switch_to_frame(driver.find_element_by_id``(&quot;topmenuFrame&quot;))driver.switch_to_default_content()· text 获取该元素的文本· submit 提交表单· get_attribute 获得属性值# --处理下拉框switch_to_alert()accept() –find12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector –cookies123456cookie = [item[&quot;name&quot;] + &quot;=&quot; + item[&quot;value&quot;] for item in driver.get_cookies()]cookiestr = &apos;;&apos;.join(item for item in cookie)driver.get_cookies（） 获得cookie信息add_cookie(cookie_dict) 向cookie添加会话信息delete_cookie(name) 删除特定(部分)的cookiedelete_all_cookies() 删除所有cookie –input123456789from selenium.webdriver.common.keys import Keyselem = driver.find_element_by_name(&quot;q&quot;)elem.clear()elem.send_keys(&quot;python&quot;)# clickclick()context_click() 右击double_click() 双击drag_and_drop() 拖动 –phantomjs12345678910111213141516from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesservice_args = []service_args.append(&apos;--load-images=no&apos;) # 关闭图片加载service_args.append(&apos;--disk-cache=yes&apos;) # 开启缓存service_args.append(&apos;--ignore-ssl-errors=true&apos;) # 忽略https错误dcap = dict(DesiredCapabilities.PHANTOMJS)# 从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器dcap[&quot;phantomjs.page.settings&quot;] = ( &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 4.4.2; en-us; SAMSUNG SCH-I545 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/1.5 Chrome/28.0.1500.94 Mobile Safari/537.36&quot;&#125;)# 不载入图片，爬页面速度会快很多dcap[&quot;phantomjs.page.settings.loadImages&quot;] = Falsedriver = webdriver.PhantomJS( desired_capabilities=dcap, service_args=service_args)driver.get_screenshot_as_file(&apos;01.png&apos;)driver.quit() –调用js12driver.execute_async_script(js)driver.execute_script(js) service_args1234567891011121314151617181920212223242526272829–user - data - dir =”[PATH]” 指定用户文件夹User Data路径，可以把书签这样的用户数据保存在系统分区以外的分区。–disk - cache - dir =”[PATH]“ 指定缓存Cache路径–disk - cache - size = 指定Cache大小，单位Byte–first run 重置到初始状态，第一次运行–incognito 隐身模式启动–disable - javascript 禁用Javascript--omnibox - popup - count = &quot;num&quot; 将地址栏弹出的提示菜单数量改为num个。我都改为15个了。--user - agent = &quot;xxxxxxxx&quot; 修改HTTP请求头部的Agent字符串，可以通过about: version页面查看修改效果--disable - plugins 禁止加载所有插件，可以增加速度。可以通过about: plugins页面查看效果--disable - javascript 禁用JavaScript，如果觉得速度慢在加上这个--disable - java 禁用java--start - maximized 启动就最大化--no - sandbox 取消沙盒模式--single - process 单进程运行--process - per - tab 每个标签使用单独进程--process - per - site 每个站点使用单独进程--in-process - plugins 插件不启用单独进程--disable - popup - blocking 禁用弹出拦截--disable - plugins 禁用插件--disable - images 禁用图像--incognito 启动进入隐身模式--enable - udd - profiles 启用账户切换菜单--proxy - pac - url 使用pac代理[via 1 / 2]--lang = zh - CN 设置语言为简体中文--disk - cache - dir 自定义缓存目录--disk - cache - size 自定义缓存最大值（单位byte）--media - cache - size 自定义多媒体缓存最大值（单位byte）--bookmark - menu 在工具 栏增加一个书签按钮--enable - sync 启用书签同步 chrome123456789101112131415161718192021222324from selenium import webdriver# 进入浏览器设置options = webdriver.ChromeOptions()# 设置中文options.add_argument(&apos;lang=zh_CN.UTF-8&apos;)chrome_options = webdriver.ChromeOptions()chrome_options.add_argument(&apos;--headless&apos;)chrome_options.add_argument(&apos;--disable-gpu&apos;)# 更换头部options.add_argument( &apos;user-agent=&quot;Mozilla/5.0 (iPod; U; CPU iPhone OS 2_1 like Mac OS X; ja-jp) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5F137 Safari/525.20&quot;&apos;)# 代理service_args = [&apos;--proxy=94.182.202.165:8080&apos;, &apos;--proxy-type=http&apos;]option.add_argument(&apos;--start-maximized&apos;) # 最大化option.add_argument(&apos;--user-data-dir=E:\\Chrome\\User Data&apos;) # 设置成用户自己的数据目录browser = webdriver.Chrome(executable_path=&apos;E:\\Chrome\\chromedriver.exe&apos;, chrome_options=options, service_args=service_args)url = &quot;https://httpbin.org/get?show_env=1&quot;browser.get(url)input(&quot;查看效果&quot;)browser.quit()# -chrome some crxoption.add_argument(&apos;--user-agent=iphone&apos;)option.add_extension(&apos;d:\crx\AdBlock_v2.17.crx&apos;)]]></content>
      <tags>
        <tag>浏览器,selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取动态网站]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2F%E6%8A%93%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99.html</url>
    <content type="text"><![CDATA[Scrapy教程12- 抓取动态网站前面我们介绍的都是去抓取静态的网站页面，也就是说我们打开某个链接，它的内容全部呈现出来。 但是如今的互联网大部分的web页面都是动态的，经常逛的网站例如京东、淘宝等，商品列表都是js，并有Ajax渲染， 下载某个链接得到的页面里面含有异步加载的内容，这样再使用之前的方式我们根本获取不到异步加载的这些网页内容。 使用Javascript渲染和处理网页是种非常常见的做法，如何处理一个大量使用Javascript的页面是Scrapy爬虫开发中一个常见的问题， 这篇文章将说明如何在Scrapy爬虫中使用scrapy-splash来处理页面中得Javascript。 scrapy-splash简介scrapy-splash利用Splash将javascript和Scrapy集成起来，使得Scrapy可以抓取动态网页。 Splash是一个javascript渲染服务，是实现了HTTP API的轻量级浏览器，底层基于Twisted和QT框架，Python语言编写。所以首先你得安装Splash实例 安装docker官网建议使用docker容器安装方式Splash。那么首先你得先安装docker 参考官方安装文档，这里我选择Ubuntu 12.04 LTS版本安装 升级内核版本，docker需要3.13内核 123$ sudo apt-get update$ sudo apt-get install linux-image-generic-lts-trusty$ sudo reboot 安装CA认证 1$ sudo apt-get install apt-transport-https ca-certificates 增加新的GPGkey 1$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D 打开/etc/apt/sources.list.d/docker.list，如果没有就创建一个，然后删除任何已存在的内容，再增加下面一句 1deb https://apt.dockerproject.org/repo ubuntu-precise main 更新APT 123$ sudo apt-get update$ sudo apt-get purge lxc-docker$ apt-cache policy docker-engine 安装 1$ sudo apt-get install docker-engine 启动docker服务 1$ sudo service docker start 验证是否启动成功 1$ sudo docker run hello-world 上面这条命令会下载一个测试镜像并在容器中运行它，它会打印一个消息，然后退出。 安装Splash拉取镜像下来 1$ sudo docker pull scrapinghub/splash 启动容器 1$ sudo docker run -p 5023:5023 -p 8050:8050 -p 8051:8051 scrapinghub/splash 现在可以通过0.0.0.0:8050(http),8051(https),5023 (telnet)来访问Splash了。 安装scrapy-splash使用pip安装 1$ pip install scrapy-splash 配置scrapy-splash在你的scrapy工程的配置文件settings.py中添加 1SPLASH_URL = 'http://192.168.203.92:8050' 添加Splash中间件，还是在settings.py中通过DOWNLOADER_MIDDLEWARES指定，并且修改HttpCompressionMiddleware的优先级 12345DOWNLOADER_MIDDLEWARES = &#123; 'scrapy_splash.SplashCookiesMiddleware': 723, 'scrapy_splash.SplashMiddleware': 725, 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 810,&#125; 默认情况下，HttpProxyMiddleware的优先级是750，要把它放在Splash中间件后面 设置Splash自己的去重过滤器 1DUPEFILTER_CLASS = 'scrapy_splash.SplashAwareDupeFilter' 如果你使用Splash的Http缓存，那么还要指定一个自定义的缓存后台存储介质，scrapy-splash提供了一个scrapy.contrib.httpcache.FilesystemCacheStorage的子类 1HTTPCACHE_STORAGE = 'scrapy_splash.SplashAwareFSCacheStorage' 如果你要使用其他的缓存存储，那么需要继承这个类并且将所有的scrapy.util.request.request_fingerprint调用替换成scrapy_splash.splash_request_fingerprint 使用scrapy-splashSplashRequest最简单的渲染请求的方式是使用scrapy_splash.SplashRequest，通常你应该选择使用这个 12345678910111213yield SplashRequest(url, self.parse_result, args=&#123; # optional; parameters passed to Splash HTTP API 'wait': 0.5, # 'url' is prefilled from request url # 'http_method' is set to 'POST' for POST requests # 'body' is set to request body for POST requests &#125;, endpoint='render.json', # optional; default is render.html splash_url='&lt;url&gt;', # optional; overrides SPLASH_URL slot_policy=scrapy_splash.SlotPolicy.PER_DOMAIN, # optional) 另外，你还可以在普通的scrapy请求中传递splash请求meta关键字达到同样的效果 123456789101112131415161718192021222324252627282930313233343536373839script = """function main(splash) local url = splash.args.url assert(splash:go(url)) assert(splash:wait(1)) assert(splash:runjs('document.getElementsByTagName("span")[0].click()')) assert(splash:wait(1)) -- return result as a JSON object return &#123; html = splash:html() &#125;end"""yield scrapy.Request(url, self.parse_result, meta=&#123; 'splash': &#123; 'args': &#123; # set rendering arguments here 'html': 1, 'png': 1, # 'url' is prefilled from request url # 'http_method' is set to 'POST' for POST requests # 'cookies': [], # 'lua_source': script, # 'body' is set to request body for POST requests &#125;, # optional parameters 'endpoint': 'render.json', # optional; default is render.json 'splash_url': '&lt;url&gt;', # optional; overrides SPLASH_URL 'slot_policy': scrapy_splash.SlotPolicy.PER_DOMAIN, 'splash_headers': &#123;&#125;, # optional; a dict with headers sent to Splash 'dont_process_response': True, # optional, default is False 'dont_send_headers': True, # optional, default is False 'magic_response': False, # optional, default is True &#125;&#125;) Splash API说明，使用SplashRequest是一个非常便利的工具来填充request.meta[&#39;splash&#39;]里的数据 meta[‘splash’][‘args’] 包含了发往Splash的参数。 meta[‘splash’][‘endpoint’] 指定了Splash所使用的endpoint，默认是render.html meta[‘splash’][‘splash_url’] 覆盖了settings.py文件中配置的Splash URL meta[‘splash’][‘splash_headers’] 运行你增加或修改发往Splash服务器的HTTP头部信息，注意这个不是修改发往远程web站点的HTTP头部 meta[‘splash’][‘dont_send_headers’] 如果你不想传递headers给Splash，将它设置成True meta[‘splash’][‘slot_policy’] 让你自定义Splash请求的同步设置 meta[‘splash’][‘dont_process_response’] 当你设置成True后，SplashMiddleware不会修改默认的scrapy.Response请求。默认是会返回SplashResponse子类响应比如SplashTextResponse meta[‘splash’][‘magic_response’] 默认为True，Splash会自动设置Response的一些属性，比如response.headers,response.body等 如果你想通过Splash来提交Form请求，可以使用scrapy_splash.SplashFormRequest，它跟SplashRequest使用是一样的。 Responses对于不同的Splash请求，scrapy-splash返回不同的Response子类 SplashResponse 二进制响应，比如对/render.png的响应 SplashTextResponse 文本响应，比如对/render.html的响应 SplashJsonResponse JSON响应，比如对/render.json或使用Lua脚本的/execute的响应 如果你只想使用标准的Response对象，就设置meta[&#39;splash&#39;][&#39;dont_process_response&#39;]=True 所有这些Response会把response.url设置成原始请求URL(也就是你要渲染的页面URL)，而不是Splash endpoint的URL地址。实际地址通过response.real_url得到 Session的处理Splash本身是无状态的，那么为了支持scrapy-splash的session必须编写Lua脚本，使用/execute 12345678910function main(splash) splash:init_cookies(splash.args.cookies) -- ... your script return &#123; cookies = splash:get_cookies(), -- ... other results, e.g. html &#125;end 而标准的scrapy session参数可以使用SplashRequest将cookie添加到当前Splash cookiejar中 使用实例]]></content>
      <tags>
        <tag>scrapy,js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2FBeautifulSoup.html</url>
    <content type="text"><![CDATA[BeautifulSoupbsfrom bs4 import BeautifulSoup bs = BeautifulSoup(content, &apos;lxml&apos;) [&apos;class&apos;] # list [&apos;id&apos;] # str [&apos;href&apos;] .name .head .body .attrs # 字典 .text # 文档 .contents # 子list .children # 生成器 .descendants # 所以子孙节点 节点使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点 通过 .next_siblings 和 .previous_siblings 全部兄弟节点 前进后退 next_element 和 .previous_element 通过 .next_elements 和 .previous_elements 所有前后节点 text.string .strings和.stripped_strings [text for text in soup.stripped_strings] .get_text(&apos;|&apos;, strip=True) find_allfind_all(name, attrs, recursive, text, **kwargs) # recursive=False只搜索子节点 def has_class_but_no_id(tag): return tag.has_attr(&apos;class&apos;) and not tag.has_attr(&apos;id&apos;) soup.find_all(has_class_but_no_id) soup.find_all(href=re.compile(&quot;elsie&quot;), id=&apos;link1&apos;) soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;} # data-* 属性 soup.find_all(text=[&quot;Tillie&quot;, &quot;Elsie&quot;, &quot;Lacie&quot;]) soup.find_all(id=&apos;link2&apos;) soup.find_all(&quot;a&quot;, limit=2) soup.find_all(&apos;a&apos;) - -soup(a) findfind(name, attrs, recursive, text, **kwargs) 1 find(tagname) # 直接搜索名为tagname的tag 如：find(&apos;head&apos;) 2 find(list) # 搜索在list中的tag，如: find([&apos;head&apos;, &apos;body&apos;]) 3 find(dict) # 搜索在dict中的tag，如:find({&apos;head&apos;:True, }) 4 find(re.compile(&apos;&apos;)) # 搜索符合正则的tag, 如:find(re.compile(&apos;^p&apos;)) select标签名不加任何修饰，类名前加点，id名前加 soup.select(&apos;title&apos;) soup.select(&apos;.sister&apos;) soup.select(&apos;#link1&apos;) soup.select(&quot;head &gt; title&quot;) # 直接子标签查找 不在同一节点的空格隔开，同一节点的不加空格 soup.select(&apos;p a[href=&quot;http://example.com/elsie&quot;]&apos;)]]></content>
      <tags>
        <tag>BeautifulSoup，解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫,aiohttp]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2F%E7%88%AC%E8%99%AB%2Caiohttp.html</url>
    <content type="text"><![CDATA[爬虫,aiohttpimport asyncio import aiohttp # 简单实例 async def aiohttp_test01(url): async with aiohttp.ClientSession() as session: async with session.get(url) as resp: print(resp.status) print(await resp.text()) loop = asyncio.get_event_loop() tasks = [aiohttp_test01(&quot;https://api.github.com/events&quot;)] loop.run_until_complete(asyncio.wait(tasks)) loop.close() #aiohttp.request(&apos;GET&apos;,url) # 其他Http方法 # session.post(&apos;http://httpbin.org/post&apos;, data=b&apos;data&apos;) # session.put(&apos;http://httpbin.org/put&apos;, data=b&apos;data&apos;) # session.delete(&apos;http://httpbin.org/delete&apos;) # session.head(&apos;http://httpbin.org/get&apos;) # session.options(&apos;http://httpbin.org/get&apos;) # session.patch(&apos;http://httpbin.org/patch&apos;, data=b&apos;data&apos;) # 自定义Headers # payload = {&apos;some&apos;: &apos;data&apos;} # headers = {&apos;content-type&apos;: &apos;application/json&apos;} # await session.post(url, data=json.dumps(payload), headers=headers) # 自定义Cookie # cookies = {&apos;cookies_are&apos;: &apos;working&apos;} # async with ClientSession(cookies=cookies) as session: # 访问Cookie: session.cookie_jar # 在URLs中传递参数 # 1. params = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} # 2. params = [(&apos;key&apos;, &apos;value1&apos;), (&apos;key&apos;, &apos;value2&apos;)] # async with session.get(&apos;http://httpbin.org/get&apos;, params=params) as resp: # assert resp.url == &apos;http://httpbin.org/get?key2=value2&amp;key1=value1&apos; # 发送数据 # payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} # async with session.post(&apos;http://httpbin.org/post&apos;, data=payload) as resp: # async with session.post(url, data=json.dumps(payload)) as resp: # print(await resp.text()) # 发送文件(1) # files = {&apos;file&apos;: open(&apos;report.xls&apos;, &apos;rb&apos;)} # await session.post(url, data=files) # 发送数据(2) # data = FormData() # data.add_field(&apos;file&apos;, # open(&apos;report.xls&apos;, &apos;rb&apos;), # filename=&apos;report.xls&apos;, # content_type=&apos;application/vnd.ms-excel&apos;) # await session.post(url, data=data) # 超时设置 # aync with session.get(&apos;https://github.com&apos;, timeout=60) as r: # 代理支持 # async with aiohttp.ClientSession() as session: # async with session.get(&quot;http://python.org&quot;, proxy=&quot;http://some.proxy.com&quot;) as resp: # print(resp.status) # async with aiohttp.ClientSession() as session: # proxy_auth = aiohttp.BasicAuth(&apos;user&apos;, &apos;pass&apos;) # async with session.get(&quot;http://python.org&quot;, proxy=&quot;http://some.proxy.com&quot;, proxy_auth=proxy_auth) as resp: # print(resp.status) # session.get(&quot;http://python.org&quot;, proxy=&quot;http://user:pass@some.proxy.com&quot;) # 返回的内容 # async with session.get(&apos;https://api.github.com/events&apos;) as resp: # print(await resp.text()) # print(await resp.text(encoding=&apos;gbk&apos;)) # print(await resp.read()) # print(await resp.json()) # 返回内容较大 # with open(filename, &apos;wb&apos;) as fd: # while True: # chunk = await resp.content.read(chunk_size) # if not chunk: # break # fd.write(chunk) # 返回的其他变量 # async with session.get(&apos;http://httpbin.org/get&apos;) as resp: # print(resp.status) # 状态码 # print(resp.headers) # Headers # print(resp.raw_headers) # 原始Headers # print(resp.cookies) # 返回的Cookie # 访问历史History # resp = await session.get(&apos;http://example.com/some/redirect/&apos;) # resp: &lt;ClientResponse(http://example.com/some/other/url/) [200]&gt; # resp.history: (&lt;ClientResponse(http://example.com/some/redirect/) [301]&gt;,) # 释放返回的Response # 1. async with session.get(url) as resp: pass # 2. await resp.release() # 连接器: Connectors # conn = aiohttp.TCPConnector() # session = aiohttp.ClientSession(connector=conn) # 限制连接池大小: # conn = aiohttp.TCPConnector(limit=30) # conn = aiohttp.TCPConnector(limit=None) async def aiohttp_test01(url,cookies=None,headers=None,proxy=None): conn = aiohttp.TCPConnector(limit=30) #cookies = {&apos;cookies_are&apos;: &apos;working&apos;} async with aiohttp.ClientSession(connector=conn,cookies=cookies) as session: #payload = {&apos;some&apos;: &apos;data&apos;} #headers = {&apos;content-type&apos;: &apos;application/json&apos;} #proxy=&quot;http://some.proxy.com&quot; async with session.get(url,timeout=10,headers=headers,proxy=proxy) as resp: print(resp.status) #await parser(resp) #print(await resp.text(encoding=&apos;gbk&apos;)) #print(await resp.read()) #print(await resp.json()) await resp.release() loop = asyncio.get_event_loop() tasks = [aiohttp_test01(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close()]]></content>
      <tags>
        <tag>爬虫,aiohttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装scrapy]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2F%E5%AE%89%E8%A3%85scrapy.html</url>
    <content type="text"><![CDATA[安装scrapy环境是linux 先安装一些依赖软件 123yum install python-develyum install libffi-develyum install openssl-devel 然后安装pyopenssl库 1pip install pyopenssl 安装xlml 123yum install python-lxmlyum install libxml2-develyum install libxslt-devel 安装service-identity 1pip install service-identity 安装twisted 1pip install scrapy 安装scrapy 1pip install scrapy -U 环境 window 12345pip install (pywin32_downloaded_from_ldf).whlpip install (twisted_downloaded_from_lfd).whlpip install twisted-winpython C:\Python35\Scripts\pywin32_postinstall.py -installpip install scrapy]]></content>
      <tags>
        <tag>安装，scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 反爬虫策略]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fpython%20%E5%8F%8D%E7%88%AC%E8%99%AB%E7%AD%96%E7%95%A5.html</url>
    <content type="text"><![CDATA[python 反爬虫策略 .限制IP地址单位时间的访问次数 ： 分析：没有哪个常人一秒钟内能访问相同网站5次，除非是程序访问，而有这种喜好的，就剩下搜索引擎爬虫和讨厌的采集器了。 弊端：一刀切，这同样会阻止搜索引擎对网站的收录 适用网站：不太依靠搜索引擎的网站 采集器会怎么做：减少单位时间的访问次数，减低采集效率 屏蔽ip 分析：通过后台计数器，记录来访者ip和访问频率，人为分析来访记录，屏蔽可疑Ip。 弊端：似乎没什么弊端，就是站长忙了点 适用网站：所有网站，且站长能够知道哪些是google或者百度的机器人 采集器会怎么做：打游击战呗！利用ip代理采集一次换一次，不过会降低采集器的效率和网速(用代理嘛)。 利用js加密网页内容 Note:这个方法我没接触过，只是从别处看来 分析：不用分析了，搜索引擎爬虫和采集器通杀 适用网站：极度讨厌搜索引擎和采集器的网站 采集器会这么做：你那么牛，都豁出去了，他就不来采你了 网页里隐藏网站版权或者一些随机垃圾文字，这些文字风格写在css文件中 分析：虽然不能防止采集，但是会让采集后的内容充满了你网站的版权说明或者一些垃圾文字，因为一般采集器不会同时采集你的css文件，那些文字没了风格，就显示出来了。 适用网站：所有网站 采集器会怎么做：对于版权文字，好办，替换掉。对于随机的垃圾文字，没办法，勤快点了。 用户登录才能访问网站内容 分析：搜索引擎爬虫不会对每个这样类型的网站设计登录程序。听说采集器可以针对某个网站设计模拟用户登录提交表单行为。 适用网站：极度讨厌搜索引擎，且想阻止大部分采集器的网站 采集器会怎么做：制作拟用户登录提交表单行为的模块 利用脚本语言做分页(隐藏分页) 分析：还是那句，搜索引擎爬虫不会针对各种网站的隐藏分页进行分析，这影响搜索引擎对其收录。但是，采集者在编写采集规则时，要分析目标网页代码，懂点脚本知识的人，就会知道分页的真实链接地址。 适用网站：对搜索引擎依赖度不高的网站，还有，采集你的人不懂脚本知识 采集器会怎么做：应该说采集者会怎么做，他反正都要分析你的网页代码，顺便分析你的分页脚本，花不了多少额外时间。 防盗链措施 (只允许通过本站页面连接查看，如：Request.ServerVariables(“HTTP_REFERER“) ) 分析：asp和php可以通过读取请求的HTTP_REFERER属性，来判断该请求是否来自本网站，从而来限制采集器，同样也限制了搜索引擎爬虫，严重影响搜索引擎对网站部分防盗链内容的收录。 适用网站：不太考虑搜索引擎收录的网站 采集器会怎么做：伪装HTTP_REFERER嘛，不难。 全flash、图片或者pdf来呈现网站内容 分析：对搜索引擎爬虫和采集器支持性不好，这个很多懂点seo的人都知道 适用网站：媒体设计类并且不在意搜索引擎收录的网站 采集器会怎么做：不采了，走人 网站随机采用不同模版 分析：因为采集器是根据网页结构来定位所需要的内容，一旦先后两次模版更换，采集规则就失效，不错。而且这样对搜索引擎爬虫没影响。 适用网站：动态网站，并且不考虑用户体验。 采集器会怎么做：一个网站模版不可能多于10个吧，每个模版弄一个规则就行了，不同模版采用不同采集规则。如果多于10个模版了，既然目标网站都那么费劲的更换模版，成全他，撤。 采用动态不规则的html标签 分析：这个比较变态。考虑到html标签内含空格和不含空格效果是一样的，所以&lt; div &gt;和&lt; div &gt;对于页面显示效果一样，但是作为采集器的标记就是两个不同标记了。如果每次页面的html标签内空格数随机，那么 采集规则就失效了。但是，这对搜索引擎爬虫没多大影响。 适合网站：所有动态且不想遵守网页设计规范的网站。 采集器会怎么做：还是有对策的，现在html cleaner还是很多的，先清理了html标签，然后再写采集规则；应该用采集规则前先清理html标签，还是能够拿到所需数据 总结： ip，账号频率，自动限速 得到延迟delay con 线程数 设置 referer user - agent js selenium splash 分析一些参数 登录 cookie 验证码，包括图像验证码、拖动验证码等等爬虫技能书]]></content>
      <tags>
        <tag>python,爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy item]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fscrapy%20item.html</url>
    <content type="text"><![CDATA[#Item Item是保存结构数据的地方，Scrapy可以将解析结果以字典形式返回，但是Python中字典缺少结构，在大型爬虫系统中很不方便。 Item提供了类字典的API，并且可以很方便的声明字段，很多Scrapy组件可以利用Item的其他信息。 定义Item定义Item非常简单，只需要继承scrapy.Item类，并将所有字段都定义为scrapy.Field类型即可 1234567import scrapyclass Product(scrapy.Item): name = scrapy.Field() price = scrapy.Field() stock = scrapy.Field() last_updated = scrapy.Field(serializer=str) Item FieldsField对象可用来对每个字段指定元数据。例如上面last_updated的序列化函数指定为str，可任意指定元数据，不过每种元数据对于不同的组件意义不一样。 Item LoaderItem Loader为我们提供了生成Item的相当便利的方法。Item为抓取的数据提供了容器，而Item Loader可以让我们非常方便的将输入填充到容器中。 下面我们通过一个例子来展示一般使用方法： 1234567891011from scrapy.loader import ItemLoaderfrom myproject.items import Productdef parse(self, response): l = ItemLoader(item=Product(), response=response) l.add_xpath('name', '//div[@class="product_name"]') l.add_xpath('name', '//div[@class="product_title"]') l.add_xpath('price', '//p[@id="price"]') l.add_css('stock', 'p#stock]') l.add_value('last_updated', 'today') # you can also use literal values return l.load_item() 注意上面的name字段是从两个xpath路径添累加后得到。 输入/输出处理器每个Item Loader对每个Field都有一个输入处理器和一个输出处理器。输入处理器在数据被接受到时执行，当数据收集完后调用ItemLoader.load_item()时再执行输出处理器，返回最终结果。 123456l = ItemLoader(Product(), some_selector)l.add_xpath('name', xpath1) # (1)l.add_xpath('name', xpath2) # (2)l.add_css('name', css) # (3)l.add_value('name', 'test') # (4)return l.load_item() # (5) 执行流程是这样的： xpath1中的数据被提取出来，然后传输到name字段的输入处理器中，在输入处理器处理完后生成结果放在Item Loader里面(这时候没有赋值给item) xpath2数据被提取出来，然后传输给(1)中同样的输入处理器，因为它们都是name字段的处理器，然后处理结果被附加到(1)的结果后面 跟2一样 跟3一样，不过这次是直接的字面字符串值，先转换成一个单元素的可迭代对象再传给输入处理器 上面4步的数据被传输给name的输出处理器，将最终的结果赋值给name字段 自定义Item Loader使用类定义语法，下面是一个例子 12345678910111213from scrapy.loader import ItemLoaderfrom scrapy.loader.processors import TakeFirst, MapCompose, Joinclass ProductLoader(ItemLoader): default_output_processor = TakeFirst() name_in = MapCompose(unicode.title) name_out = Join() price_in = MapCompose(unicode.strip) # ... 通过_in和_out后缀来定义输入和输出处理器，并且还可以定义默认的ItemLoader.default_input_processor和ItemLoader.default_input_processor. 在Field定义中声明输入/输出处理器还有个地方可以非常方便的添加输入/输出处理器，那就是直接在Field定义中 1234567891011121314151617import scrapyfrom scrapy.loader.processors import Join, MapCompose, TakeFirstfrom w3lib.html import remove_tagsdef filter_price(value): if value.isdigit(): return valueclass Product(scrapy.Item): name = scrapy.Field( input_processor=MapCompose(remove_tags), output_processor=Join(), ) price = scrapy.Field( input_processor=MapCompose(remove_tags, filter_price), output_processor=TakeFirst(), ) 优先级： 在Item Loader中定义的field_in和field_out Filed元数据(input_processor和output_processor关键字) Item Loader中的默认的 Tips：一般来讲，将输入处理器定义在Item Loader的定义中field_in，然后将输出处理器定义在Field元数据中 Item Loader上下文Item Loader上下文被所有输入/输出处理器共享，比如你有一个解析长度的函数 1234def parse_length(text, loader_context): unit = loader_context.get('unit', 'm') # ... length parsing code goes here ... return parsed_length 初始化和修改上下文的值 1234567loader = ItemLoader(product)loader.context['unit'] = 'cm'loader = ItemLoader(product, unit='cm')class ProductLoader(ItemLoader): length_out = MapCompose(parse_length, unit='cm') 内置的处理器 Identity 啥也不做 TakeFirst 返回第一个非空值，通常用作输出处理器 Join 将结果连起来，默认使用空格’ ‘ Compose 将函数链接起来形成管道流，产生最后的输出 MapCompose 跟上面的Compose类似，区别在于内部结果在函数中的传递方式. 它的输入值是可迭代的，首先将第一个函数依次作用于所有值，产生新的可迭代输入，作为第二个函数的输入，最后生成的结果连起来返回最终值，一般用在输入处理器中。 SelectJmes 使用json路径来查询值并返回结果]]></content>
      <tags>
        <tag>scrapy,item</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item Pipeline]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2FItem%20Pipeline.html</url>
    <content type="text"><![CDATA[Scrapy教程06- Item Pipeline当一个item被蜘蛛爬取到之后会被发送给Item Pipeline，然后多个组件按照顺序处理这个item。 每个Item Pipeline组件其实就是一个实现了一个简单方法的Python类。他们接受一个item并在上面执行逻辑，还能决定这个item到底是否还要继续往下传输，如果不要了就直接丢弃。 使用Item Pipeline的常用场景： 清理HTML数据 验证被抓取的数据(检查item是否包含某些字段) 重复性检查(然后丢弃) 将抓取的数据存储到数据库中 编写自己的Pipeline定义一个Python类，然后实现方法process_item(self, item, spider)即可，返回一个字典或Item，或者抛出DropItem异常丢弃这个Item。 或者还可以实现下面几个方法： open_spider(self, spider) 蜘蛛打开的时执行 close_spider(self, spider) 蜘蛛关闭时执行 from_crawler(cls, crawler) 可访问核心组件比如配置和信号，并注册钩子函数到Scrapy中 Item Pipeline示例价格验证我们通过一个价格验证例子来看看怎样使用 12345678910111213from scrapy.exceptions import DropItemclass PricePipeline(object): vat_factor = 1.15 def process_item(self, item, spider): if item['price']: if item['price_excludes_vat']: item['price'] = item['price'] * self.vat_factor return item else: raise DropItem("Missing price in %s" % item) 将item写入json文件下面的这个Pipeline将所有的item写入到一个单独的json文件，一行一个item 1234567891011import jsonclass JsonWriterPipeline(object): def __init__(self): self.file = open('items.jl', 'wb') def process_item(self, item, spider): line = json.dumps(dict(item)) + "\n" self.file.write(line) return item 将item存储到MongoDB中这个例子使用pymongo来演示怎样讲item保存到MongoDB中。 MongoDB的地址和数据库名在配置中指定，这个例子主要是向你展示怎样使用from_crawler()方法，以及如何清理资源。 123456789101112131415161718192021222324252627import pymongoclass MongoPipeline(object): collection_name = 'scrapy_items' def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE', 'items') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[self.collection_name].insert(dict(item)) return item 重复过滤器假设我们的item里面的id字典是唯一的，但是我们的蜘蛛返回了多个相同id的item 12345678910111213from scrapy.exceptions import DropItemclass DuplicatesPipeline(object): def __init__(self): self.ids_seen = set() def process_item(self, item, spider): if item['id'] in self.ids_seen: raise DropItem("Duplicate item found: %s" % item) else: self.ids_seen.add(item['id']) return item 激活一个Item Pipeline组件你必须在配置文件中将你需要激活的Pipline组件添加到ITEM_PIPELINES中 1234ITEM_PIPELINES = &#123; 'myproject.pipelines.PricePipeline': 300, 'myproject.pipelines.JsonWriterPipeline': 800,&#125; 后面的数字表示它的执行顺序，从低到高执行，范围0-1000]]></content>
      <tags>
        <tag>scrapy,Pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态配置爬虫]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2F%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E7%88%AC%E8%99%AB.html</url>
    <content type="text"><![CDATA[Scrapy教程10- 动态配置爬虫有很多时候我们需要从多个网站爬取所需要的数据，比如我们想爬取多个网站的新闻，将其存储到数据库同一个表中。我们是不是要对每个网站都得去定义一个Spider类呢？ 其实不需要，我们可以通过维护一个规则配置表或者一个规则配置文件来动态增加或修改爬取规则，然后程序代码不需要更改就能实现多个网站爬取。 要这样做，我们就不能再使用前面的scrapy crawl test这种命令了，我们需要使用编程的方式运行Scrapy spider，参考官方文档 脚本运行Scrapy可以利用scrapy提供的核心API通过编程方式启动scrapy，代替传统的scrapy crawl启动方式。 Scrapy构建于Twisted异步网络框架基础之上，因此你需要在Twisted reactor里面运行。 首先你可以使用scrapy.crawler.CrawlerProcess这个类来运行你的spider，这个类会为你启动一个Twisted reactor，并能配置你的日志和shutdown处理器。所有的scrapy命令都使用这个类。 12345678import scrapyfrom scrapy.crawler import CrawlerProcessfrom scrapy.utils.project import get_project_settingsprocess = CrawlerProcess(get_project_settings())process.crawl(MySpider)process.start() # the script will block here until the crawling is finished 然后你就可以直接执行这个脚本 1python run.py 另外一个功能更强大的类是scrapy.crawler.CrawlerRunner，推荐你使用这个 123456789101112131415from twisted.internet import reactorimport scrapyfrom scrapy.crawler import CrawlerRunnerfrom scrapy.utils.log import configure_loggingclass MySpider(scrapy.Spider): # Your spider definition ...configure_logging(&#123;'LOG_FORMAT': '%(levelname)s: %(message)s'&#125;)runner = CrawlerRunner()d = runner.crawl(MySpider)d.addBoth(lambda _: reactor.stop())reactor.run() # the script will block here until the crawling is finished 同一进程运行多个spider默认情况当你每次执行scrapy crawl命令时会创建一个新的进程。但我们可以使用核心API在同一个进程中同时运行多个spider 123456789101112131415161718192021import scrapyfrom twisted.internet import reactorfrom scrapy.crawler import CrawlerRunnerfrom scrapy.utils.log import configure_loggingclass MySpider1(scrapy.Spider): # Your first spider definition ...class MySpider2(scrapy.Spider): # Your second spider definition ...configure_logging()runner = CrawlerRunner()runner.crawl(MySpider1)runner.crawl(MySpider2)d = runner.join()d.addBoth(lambda _: reactor.stop())reactor.run() # the script will block here until all crawling jobs are finished 定义规则表好了言归正传，有了前面的脚本启动基础，就可以开始我们的动态配置爬虫了。 我们的需求是这样的，从两个不同的网站爬取我们所需要的新闻文章，然后存储到article表中。 首先我们需要定义规则表和文章表，通过动态的创建蜘蛛类，我们以后就只需要维护规则表即可了。这里我使用SQLAlchemy框架来映射数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- encoding: utf-8 -*-"""Topic: 定义数据库模型实体Desc :"""import datetimefrom sqlalchemy.engine.url import URLfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_engine, Column, Integer, String, Text, DateTimefrom coolscrapy.settings import DATABASEBase = declarative_base()class ArticleRule(Base): """自定义文章爬取规则""" __tablename__ = 'article_rule' id = Column(Integer, primary_key=True) # 规则名称 name = Column(String(30)) # 运行的域名列表，逗号隔开 allow_domains = Column(String(100)) # 开始URL列表，逗号隔开 start_urls = Column(String(100)) # 下一页的xpath next_page = Column(String(100)) # 文章链接正则表达式(子串) allow_url = Column(String(200)) # 文章链接提取区域xpath extract_from = Column(String(200)) # 文章标题xpath title_xpath = Column(String(100)) # 文章内容xpath body_xpath = Column(Text) # 发布时间xpath publish_time_xpath = Column(String(30)) # 文章来源 source_site = Column(String(30)) # 规则是否生效 enable = Column(Integer)class Article(Base): """文章类""" __tablename__ = 'articles' id = Column(Integer, primary_key=True) url = Column(String(100)) title = Column(String(100)) body = Column(Text) publish_time = Column(String(30)) source_site = Column(String(30)) 定义文章Item这个很简单了，没什么需要说明的 123456789import scrapyclass Article(scrapy.Item): title = scrapy.Field() url = scrapy.Field() body = scrapy.Field() publish_time = scrapy.Field() source_site = scrapy.Field() 定义ArticleSpider接下来我们将定义爬取文章的蜘蛛，这个spider会使用一个Rule实例来初始化，然后根据Rule实例中的xpath规则来获取相应的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344from coolscrapy.utils import parse_textfrom scrapy.spiders import CrawlSpider, Rulefrom scrapy.linkextractors import LinkExtractorfrom coolscrapy.items import Articleclass ArticleSpider(CrawlSpider): name = "article" def __init__(self, rule): self.rule = rule self.name = rule.name self.allowed_domains = rule.allow_domains.split(",") self.start_urls = rule.start_urls.split(",") rule_list = [] # 添加`下一页`的规则 if rule.next_page: rule_list.append(Rule(LinkExtractor(restrict_xpaths=rule.next_page))) # 添加抽取文章链接的规则 rule_list.append(Rule(LinkExtractor( allow=[rule.allow_url], restrict_xpaths=[rule.extract_from]), callback='parse_item')) self.rules = tuple(rule_list) super(ArticleSpider, self).__init__() def parse_item(self, response): self.log('Hi, this is an article page! %s' % response.url) article = Article() article["url"] = response.url title = response.xpath(self.rule.title_xpath).extract() article["title"] = parse_text(title, self.rule.name, 'title') body = response.xpath(self.rule.body_xpath).extract() article["body"] = parse_text(body, self.rule.name, 'body') publish_time = response.xpath(self.rule.publish_time_xpath).extract() article["publish_time"] = parse_text(publish_time, self.rule.name, 'publish_time') article["source_site"] = self.rule.source_site return article 要注意的是start_urls，rules等都初始化成了对象的属性，都由传入的rule对象初始化，parse_item方法中的抽取规则也都有rule对象提供。 编写pipeline存储到数据库中我们还是使用SQLAlchemy来将文章Item数据存储到数据库中 12345678910111213141516171819202122232425262728293031323334353637@contextmanagerdef session_scope(Session): """Provide a transactional scope around a series of operations.""" session = Session() try: yield session session.commit() except: session.rollback() raise finally: session.close()class ArticleDataBasePipeline(object): """保存文章到数据库""" def __init__(self): engine = db_connect() create_news_table(engine) self.Session = sessionmaker(bind=engine) def open_spider(self, spider): """This method is called when the spider is opened.""" pass def process_item(self, item, spider): a = Article(url=item["url"], title=item["title"].encode("utf-8"), publish_time=item["publish_time"].encode("utf-8"), body=item["body"].encode("utf-8"), source_site=item["source_site"].encode("utf-8")) with session_scope(self.Session) as session: session.add(a) def close_spider(self, spider): pass 修改run.py启动脚本我们将上面的run.py稍作修改即可定制我们的文章爬虫启动脚本 12345678910111213141516171819202122232425262728293031import loggingfrom spiders.article_spider import ArticleSpiderfrom twisted.internet import reactorfrom scrapy.crawler import CrawlerRunnerfrom scrapy.utils.project import get_project_settingsfrom scrapy.utils.log import configure_loggingfrom coolscrapy.models import db_connectfrom coolscrapy.models import ArticleRulefrom sqlalchemy.orm import sessionmakerif __name__ == '__main__': settings = get_project_settings() configure_logging(settings) db = db_connect() Session = sessionmaker(bind=db) session = Session() rules = session.query(ArticleRule).filter(ArticleRule.enable == 1).all() session.close() runner = CrawlerRunner(settings) for rule in rules: # stop reactor when spider closes # runner.signals.connect(spider_closing, signal=signals.spider_closed) runner.crawl(ArticleSpider, rule=rule) d = runner.join() d.addBoth(lambda _: reactor.stop()) # blocks process so always keep as the last statement reactor.run() logging.info('all finished.') OK，一切搞定。现在我们可以往ArticleRule表中加入成百上千个网站的规则，而不用添加一行代码，就可以对这成百上千个网站进行爬取。 当然你完全可以做一个Web前端来完成维护ArticleRule表的任务。当然ArticleRule规则也可以放在除了数据库的任何地方，比如配置文件。 你可以在GitHub上看到本文的完整项目源码。]]></content>
      <tags>
        <tag>scrapy,多个spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy img]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fscrapy%20img.html</url>
    <content type="text"><![CDATA[img将所有下载的图片转换成通用的格式（JPG）和模式（RGB） 避免重新下载最近已经下载过的图片 缩略图生成 检测图像的宽/高，确保它们满足最小限制 itemsclass MyItem(scrapy.Item): image_urls = scrapy.Field() images = scrapy.Field() settingITEM_PIPELINES = {&apos;scrapy.contrib.pipeline.images.ImagesPipeline&apos;: 1} IMAGES_STORE = &apos;/path/to/valid/dir&apos; #90天的图片失效期限 IMAGES_EXPIRES = 90 #缩略图生成 IMAGES_THUMBS = { &apos;small&apos;: (50, 50), &apos;big&apos;: (270, 270), } #滤出小图片 IMAGES_MIN_HEIGHT = 110 IMAGES_MIN_WIDTH = 110 定制图片管道的例子import scrapy from scrapy.contrib.pipeline.images import ImagesPipeline from scrapy.exceptions import DropItem class MyImagePipelines(ImagesPipeline): def get_media_requests(self, item, info): for image_url in item[&apos;image_urls&apos;]: # 这里我把item传过去,因为后面需要用item里面的书名和章节作为文件名 yield scrapy.Request(image_url, meta={&apos;item&apos;: item}) def item_completed(self, results, item, info): image_paths = [x[&apos;path&apos;] for ok, x in results if ok] if not image_paths: raise DropItem(&quot;Item contains no images&quot;) return item def file_path(self, request, response=None, info=None): item = request.meta[&apos;item&apos;] # 从URL提取图片的文件名 image_guid = request.url.split(&apos;/&apos;)[-1] # 拼接最终的文件名,格式:full/{书名}/{章节}/图片文件名.jpg filename = u&apos;full/{0[bookname]}/{0[chapter]}/{1}&apos;.format(item, image_guid) return filename]]></content>
      <tags>
        <tag>scrapy,img</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath,css]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fxpath%2Ccss.html</url>
    <content type="text"><![CDATA[[TOC] 例子文本一response.xpath(&apos;//title/text()&apos;).extract() response.css(&apos;title::text&apos;).extract() 文本 包括子节点sel.xpath(&quot;//a[1]//text()&quot;).extract() 文本 包括子节点 合并sel.xpath(&quot;string(//a[1])&quot;).extract() 属性response.xpath(&apos;//img/@src&apos;).extract() response.css(&apos;img::attr(src)&apos;).extract() 混合response.css(&apos;img&apos;).xpath(&apos;@src&apos;).extract() response.xpath(&apos;//img&apos;).css(&apos;::attr(src)&apos;).extract() 精确response.xpath(&apos;//div[@id=&quot;images&quot;]/a/text()&apos;).extract() response.css(&apos;div#images a::text&apos;).extract() 模糊response.xpath(&apos;//div[contains(@id, &quot;image&quot;)]/a/text()&apos;).extract() response.css(&apos;div[id*=image] a::text&apos;).extract() 正则response.xpath(&apos;//a[contains(@href, &quot;image&quot;)]/text()&apos;).re(r&apos;Name:\s*(.*)&apos;) ###第一个 response.xpath(‘//div[@id=”images”]/a/text()’).extract_first() ###默认值 response.xpath(‘//div[@id=”not-exists”]/text()’).extract_first(default=’not-found’) XPath建议使用text作为条件时避免使用.//text(),直接使用. 12&gt;&gt;&gt; sel.xpath(&quot;//a[contains(., &apos;Next Page&apos;)]&quot;).extract()[u&apos;&lt;a href=&quot;#&quot;&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;&apos;] //node1和(//node)1区别 //node1: 选择所有位于第一个子节点位置的node节点 (//node)1: 选择所有的node节点，然后返回结果中的第一个node节点12345sel = Selector(text=doc, type=&quot;html&quot;)xp = lambda x: sel.xpath(x).extract()xp(&quot;(//li)[1]&quot;)xp(&quot;//ul/li[1]&quot;) #多个xp(&quot;(//ul/li)[1]&quot;) #一个 CSS 12345678910111213141516171819p 选择所有 &lt;p&gt; 元素。.intro 选择 class=&quot;intro&quot; 的所有元素#firstname 选择 id=&quot;firstname&quot; 的所有元素。::attr(src) ::text 选择被用户选取的元素部分a[src^=&quot;https&quot;] 选择其 src 属性值以 &quot;https&quot; 开头的每个 &lt;a&gt; 元素。a[src$=&quot;.pdf&quot;] 选择其 src 属性以 &quot;.pdf&quot; 结尾的所有 &lt;a&gt; 元素。a[src*=&quot;abc&quot;] 选择其 src 属性中包含 &quot;abc&quot; 子串的每个 &lt;a&gt; 元素。div,p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。[target] 选择带有 target 属性所有元素。[target=_blank] 选择 target=&quot;_blank&quot; 的所有元素。[title~=flower] 选择 title 属性包含单词 &quot;flower&quot; 的所有元素:not(p) 选择非 &lt;p&gt; 元素的每个元素。p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 XpathXPath相对路径 不使用/开头的 12345678910111213141516171819202122232425262728293031323334353637383940414243/ 从根元素选取// 从全文档选取. 当前元素.. 父元素@ 属性* 匹配任何元素@* 匹配任何属性node() 匹配任何类型元素last()not()p[not(contains(@class, ‘title’))]#轴ancestor 选取当前节点的所有先辈（父、祖父等）。ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。attribute 选取当前节点的所有属性。child 选取当前节点的所有子元素。descendant 选取当前节点的所有后代元素（子、孙等）。descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。following 选取文档中当前节点的结束标签之后的所有节点。namespace 选取当前节点的所有命名空间节点。parent 选取当前节点的父节点。preceding 选取文档中当前节点的开始标签之前的所有节点。preceding-sibling 选取当前节点之前的所有同级节点。self 选取当前节点。#运算|+-*div=!=&lt;&lt;=&gt;&gt;=orandmod #计算除法的余数]]></content>
      <tags>
        <tag>xpath,css,scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Fgit.html</url>
    <content type="text"><![CDATA[git一、新建代码库git init //初始化 git add README //更新README文件 .为所有文件 git commit -m &apos;first commit&apos; //提交更新，并注释信息“first commit” git remote add origin git@github.com:yeayee/helloworld.git //连接远程github项目 git push origin master //将本地项目更新到github项目上去 git clone git@github.com:yeayee/helloworld.git helloworld //把仓库复制到自己的电脑上 git remote rm origin //删除源origin git pull origin master //将github上的项目拉下来 git config --global core.editor Notepad++ //设置编辑器 git config user.name //查看配置信息 git help &lt;verb&gt; //查看帮助信息 git status //查看文件当前处于什么状态 git log //回顾提交历史 git diff //查看尚未暂存文件更新了哪些部分 git remote -v //查看你当前项目远程连接的是哪个仓库地址 git fetch origin //取得远程更新，这里可以看做是准备要取了 git merge origin/master //把更新的内容合并到本地分支origin/master git rm src/com/hzh/hibernate/dao/aaa.java //移除我们删除了的那个文件aaa.java git rm src/com/hzh/hibernate/bbb/ -r //-r会把bbb/目录下的所有内容一次性移除 git branch testbranch //命名分支 git checkout testbranch //将testbranch分支设置为当前工作分支 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 cd ~/.ssh //查看计算机ssh密钥 ssh-keygen -t rsa -C &quot;85362057@qq.com&quot; //填写email地址，生成密钥 ssh -T git@github.com //测试连接是否成功 git config --global github.token e97279836f0d415a3954c1193dba522f //配置token # 显示当前的Git配置 $ git config --list git config --global user.email &quot;1726448967@qq.com&quot; git config --global user.name &quot;bolearnpython&quot; $ git help $ git help config # 防止http协议每次都要输入密码： $ git config --global credential.helper &apos;cache --timeout=36000000&apos; #秒数 # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 git config --global user.name &quot;jake&quot; git config --global user.email jake@gmail.com #配置你的编缉器 $ git config --global core.editor emacs 关闭Ignore文件的功能 git config core.fileMode false 删除全局设置 git config --global --unset &lt;entry-name&gt; 清除.gitignore文件中记录的文件 git clean -X -f git clean &lt;file_name&gt; -f 把某一个分支到导出成一个文件 git bundle create &lt;file&gt; &lt;branch-name&gt; 查看两个星期内的改动 git whatchanged --since=&apos;2 weeks ago&apos; 三、增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交git commit --amend 查看commit历史 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支1、在本地创建新分支：git branch newbranch 2、在本地切换到新分支：git checkout newbranch 3、将新分支推送到github：git push origin newbranch 4、在本地删除一个分支：git branch -d newbranch 5、在Github远端删除一个分支：git push origin :newbranch 重命名本地分支名。 git branch -m xue xueweihan # 列出所有本地分支 $ git branch # 列出所有远程分支 -r参数相当于：remote $ git branch -r # 列出所有本地分支和远程分支 -a参数相当于：all $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关忽略系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息# 显示有变更的文件 $ git status 展示忽略的文件 git status --ignored # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] 修改远程仓库的url git remote set-url origin &lt;URL&gt; # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] git pull origin master # 拉取更新 # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销$ git checkout master # 切到master # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到工作区 $ git checkout [commit] [file] 创建并切换到该分支 git checkout -b &lt;branch-name&gt; 2.git checkout -b newBranch origin/master 拷贝一份远程分支origin/master的内容到本地，并新建一个名为newBranch的分支。 # 恢复上一个commit的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] git revert master~2 回滚 git revert &lt;commit_id&gt; -m &lt;parent_id&gt; 回滚合并 抛弃本地仓库的所有版本(commit)，回到远程仓库的状态。 git fetch --all &amp;&amp; git reset --hard origin/master 十、其他# 生成一个可供发布的压缩包 $ git archive [git]git忽略文件 可以通过创建~/.gitignore_global并添加到git全局配置以减少每层目录的规则重复定义。 使用命令git config --global core.excludesfile ~/.gitignore_global即可 .gitignore_global文件中写入要忽略的文件后缀： 如要忽略“.pyc”的文件，就在.gitignore_global文件中写入 “*.pyc”就ok了。 [git]git add 增加文件，文件名乱码 在bash提示符下输入： git config --global core.quotepath false 展示所有tracked的文件 git ls-files -t 展示所有untracked的文件 git ls-files --others 展示所有忽略的文件 git ls-files --others -i --exclude-standard git stash -u 展示所有stashes git stash list 回到某个stash的状态 git stash apply &lt;stash@{n}&gt; 回到最后一个stash的状态，并删除这个stash git stash pop 删除所有的stash git stash clear 从stash中拿出某个文件的修改 git checkout &lt;stash@{n}&gt; -- &lt;file_path&gt; 使用http代理$ git config --global http.proxy http://proxyuser:proxypwd@proxy.server.com:8080 $ git config --global http.proxy http://127.0.0.1:8787 # lantern 查看使用代理： $ git config --global --get http.proxy 取消http代理： $ git config --global --unset http.proxy 使用socks代理 $ git config --global https.proxy &apos;socks5://proxyuser:proxypwd@proxy.server.com:8080&apos; 取消socks代理： $ git config --global --unset https.proxy 常用 git 命令清单。几个专用名词的译名如下。Workspace： 工作区 Index / Stage： 暂存区 Repository： 仓库区（或本地仓库） Remote： 远程仓库 master分支， 即主分支。任何项目都必须有个这个分支。对项目进行tag或发布版本等操作，都必须在该分支上进行。 develop分支，即开发分支，从master分支上检出。团队成员一般不会直接更改该分支，而是分别从该分支检出自己的feature分支，开发完成后将feature分支上的改动merge回develop分支。同时release分支由此分支检出。 release分支，即发布分支，从develop分支上检出。该分支用作发版前的测试，可进行简单的bug修复。如果bug修复比较复杂，可merge回develop分支后由其他分支进行bug修复。此分支测试完成后，需要同时merge到master和develop分支上。 feature分支，即功能分支，从develop分支上检出。团队成员中每个人都维护一个自己的feature分支，并进行开发工作，开发完成后将此分支merge回develop分支。此分支一般用来开发新功能或进行项目维护等。 fix分支， 即补丁分支，由develop分支检出，用作bug修复，bug修复完成需merge回develop分支，并将其删除。所以该分支属于临时性分支。 hotfix分支， 即热补丁分支。和fix分支的区别在于，该分支由master分支检出，进行线上版本的bug修复，修复完成后merge回master分支，并merge到develop分支上，merge完成后也可以将其删除，也属于临时性分支。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误合集]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%2F%E9%94%99%E8%AF%AF%E5%90%88%E9%9B%86.html</url>
    <content type="text"><![CDATA[错误112test=&quot;(&apos;0&apos;,&apos;!LZX&apos;,&apos;\\x00\\x00\\x00\\x00\\x66\\xe7\\x85\\x47&apos;,&apos;3b58a39341b3e74d93cc7dd083e634d0d5f92779b9d9f5fd64e9a76c49e3167d201ed432c172732f933fff1ad7e35c00b8e5996ded003d87&apos;,&apos;2&apos;)&quot;eval(test) 第三个变了，’\’转义符在命令行参数输入中的错误]]></content>
      <tags>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fpython%2Freadme.html</url>
    <content type="text"><![CDATA[欢迎使用小书匠编辑器]]></content>
  </entry>
  <entry>
    <title><![CDATA[adb]]></title>
    <url>%2F2017%2F11%2F02%2Fpython%2Fadb.html</url>
    <content type="text"><![CDATA[adb adb 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 与应用交互 调起 Activity 调起 Service 发送广播 强制停止应用 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 更多 adb shell 命令 查看进程 查看实时资源占用情况 其它 常见问题 启动 adb server 失败 adb 的非官方实现 致谢 参考链接 基本用法 命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理 查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理 查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。 | 1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。 | | INSTALL_FAILED_INVALID_INSTALL_LOCATION | 1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。 | 1. 切换安装位置，添加或删除 -s 参数; 2. 打包时不与 ROM 使用相同签名。 | | INSTALL_FAILED_MEDIA_UNAVAILABLE | 安装位置不可用 | 一般为 sdcard，确认 sdcard 可用或安装到内置存储 | | INSTALL_FAILED_VERIFICATION_TIMEOUT | 验证安装包超时 | | | INSTALL_FAILED_VERIFICATION_FAILURE | 验证安装包失败 | | | INSTALL_FAILED_PACKAGE_CHANGED | 应用与调用程序期望的不一致 | | | INSTALL_FAILED_UID_CHANGED | 以前安装过该应用，与本次分配的 UID 不一致 | 清除以前安装过的残留文件 | | INSTALL_FAILED_VERSION_DOWNGRADE | 已经安装了该应用更高版本 | 使用 -d 参数 | | INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE | 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 | | | INSTALL_PARSE_FAILED_NOT_APK | 指定路径不是文件，或不是以 .apk 结尾 | | | INSTALL_PARSE_FAILED_BAD_MANIFEST | 无法解析的 AndroidManifest.xml 文件 | | | INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION | 解析器遇到异常 | | | INSTALL_PARSE_FAILED_NO_CERTIFICATES | 安装包没有签名 | | | INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES | 已安装该应用，且签名与 APK 文件不一致 | 先卸载设备上的该应用，再安装 | | INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING | 解析 APK 文件时遇到 CertificateEncodingException | | | INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME | manifest 文件里没有或者使用了无效的包名 | | | INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID | manifest 文件里指定了无效的共享用户 ID | | | INSTALL_PARSE_FAILED_MANIFEST_MALFORMED | 解析 manifest 文件时遇到结构性错误 | | | INSTALL_PARSE_FAILED_MANIFEST_EMPTY | 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） | | | INSTALL_FAILED_INTERNAL_ERROR | 因系统问题安装失败 | | | INSTALL_FAILED_USER_RESTRICTED | 用户被限制安装应用 | | | INSTALL_FAILED_DUPLICATE_PERMISSION | 应用尝试定义一个已经存在的权限名称 | | | INSTALL_FAILED_NO_MATCHING_ABIS | 应用包含设备的应用程序二进制接口不支持的 native code | | | INSTALL_CANCELED_BY_USER | 应用安装需要在设备上确认，但未操作设备或点了取消 | 在设备上同意安装 | | INSTALL_FAILED_ACWF_INCOMPATIBLE | 应用程序与设备不兼容 | | | does not contain AndroidManifest.xml | 无效的 APK 文件 | | | is not a valid zip file | 无效的 APK 文件 | | | Offline | 设备未连接成功 | 先将设备与 adb 连接成功 | | unauthorized | 设备未授权允许调试 | | | error: device not found | 没有连接成功的设备 | 先将设备与 adb 连接成功 | | protocol failure | 设备已断开连接 | 先将设备与 adb 连接成功 | | Unknown option: -s | Android 2.2 以下不支持安装到 sdcard | 不使用 -s 参数 | | No space left on device | 空间不足 | 清理空间 | | Permission denied … sdcard … | sdcard 不可用 | | | signatures do not match the previously installed version; ignoring! | 已安装该应用且签名不一致 | 先卸载设备上的该应用，再安装 | 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot; 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 文件管理 复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息 型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 &apos;........8.6.0.9.&apos; 0x00000010: 00350035 00320030 00370037 00350038 &apos;5.5.0.2.7.7.8.5.&apos; 0x00000020: 00340030 00000031 &apos;0.4.1... &apos;) 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能 屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png Mac OS X 1adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid=&quot;TP-LINK_9DFC&quot; scan_ssid=1 psk=&quot;123456789&quot; key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid=&quot;TP-LINK_F11E&quot; psk=&quot;987654321&quot; key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令 重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题 启动 adb server 失败出错提示 1error: protocol fault (couldn&apos;t read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy]]></title>
    <url>%2F2017%2F11%2F02%2Fpython%2Fsqlalchemy.html</url>
    <content type="text"><![CDATA[sqlalchemy连接123456import sqlalchemyimport sqlalchemy.ormimport sqlalchemy.ext.declarative# 利用数据库字符串构造engine, echo为True将打印所有的sql语句, 其他数据库的链接方式可自行百度# engine = sqlalchemy.create_engine(&quot;mysql+pymysql://username:password@hostname/dbname&quot;, encoding=&quot;utf8&quot;, echo=True)engine = sqlalchemy.create_engine(&quot;mysql+pymysql://dba_0:mimadba_0@101.200.174.172/data_secret&quot;, encoding=&quot;utf8&quot;, echo=False) 利用engine创建connection,因为使用了with所以不需要close操作123456789101112131415161718192021with engine.connect() as conn: # 最基础的用法 result = conn.execute(&quot;select * from tablename limit 10;&quot;) for item in result: print(item) # execute的几种用法,这里具体还是得参考pymysql的用法,不需要执行commit操作 conn.execute(&quot;insert into tablename(id, url, title) values(1, &apos;url1&apos;, &apos;title1&apos;);&quot;) conn.execute(&quot;insert into tablename(id, url, title) values(%s, %s, %s);&quot;, 2, &quot;url2&quot;, &quot;title2&quot;) conn.execute(&quot;insert into tablename(id, url, title) values(%s, %s, %s)&quot;, (3, &quot;url3&quot;, &quot;title3&quot;)) conn.execute(&quot;insert into tablename(id, url, title) values(%s, %s, %s)&quot;, [(31, &quot;url31&quot;, &quot;title31&quot;), (32, &quot;url32&quot;, &quot;title32&quot;)]) # 使用事务可以进行批量提交和回滚 trans = conn.begin() try: conn.execute(&quot;insert into tablename(id, url, title) values(%s, %s, %s)&quot;, [(4, &quot;url4&quot;, &quot;title4&quot;), (5, &quot;url5&quot;, &quot;title5&quot;)]) trans.commit() except Exception as excep: trans.rollback() raise trans.close() model12345678910111213141516171819202122232425262728293031323334353637383940# 首先需要生成一个BaseModel类,作为所有模型类的基类BaseModel = sqlalchemy.ext.declarative.declarative_base()# 构建数据模型Userclass User(BaseModel): __tablename__ = &quot;Users&quot; # 表名 __table_args__ = &#123; &quot;mysql_engine&quot;: &quot;InnoDB&quot;, # 表的引擎 &quot;mysql_charset&quot;: &quot;utf8&quot;, # 表的编码格式 &#125; # 表结构,具体更多的数据类型自行百度 id = sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True, autoincrement=True) name = sqlalchemy.Column(&quot;name&quot;, sqlalchemy.String(50), nullable=False) age = sqlalchemy.Column(&quot;age&quot;, sqlalchemy.Integer, default=0) # 添加角色id外键,关联到表Roles的id属性 role_id = sqlalchemy.Column(&quot;role_id&quot;, sqlalchemy.Integer, sqlalchemy.ForeignKey(&quot;Roles.id&quot;)) # 添加关系属性,关联到本实例的role_id外键属性上 role = sqlalchemy.orm.relationship(&quot;Role&quot;, foreign_keys=&quot;User.role_id&quot;) # 添加关系属性,关联到本实例的role_id外键属性上,如果使用了这种方式,Role模型中的users可以省略 # role = sqlalchemy.orm.relationship(&quot;Role&quot;, foreign_keys=&quot;User.role_id&quot;, backref=sqlalchemy.orm.backref(&quot;users&quot;))# 构建数据模型Roleclass Role(BaseModel): __tablename__ = &quot;Roles&quot; # 表名 __table_args__ = &#123; &quot;mysql_engine&quot;: &quot;InnoDB&quot;, # 表的引擎 &quot;mysql_charset&quot;: &quot;utf8&quot;, # 表的编码格式 &#125; # 表结构,具体更多的数据类型自行百度 id = sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True) name = sqlalchemy.Column(&quot;name&quot;, sqlalchemy.String(50), unique=True) # 添加关系属性,关联到实例User的role_id外键属性上 users = sqlalchemy.orm.relationship(&quot;User&quot;, foreign_keys=&quot;User.role_id&quot;) 增删改查# 利用Session对象连接数据库 DBSessinon = sqlalchemy.orm.sessionmaker(bind=engine) # 创建会话类 session = DBSessinon() # 创建会话对象 # 删除所有表 BaseModel.metadata.drop_all(engine) # 创建所有表,如果表已经存在,则不会创建 BaseModel.metadata.create_all(engine) try: # 清空数据,不需要commit操作 session.query(User).filter(User.id != -1).delete() session.query(Role).filter(Role.id != -1).delete() # 删除数据的另外一种形式:session.delete() # 插入数据,这里的一个实例只插入一次,第二次插入不生效 session.add(Role(id=1, name=&quot;student&quot;)) session.add(Role(id=2, name=&quot;teacher&quot;)) session.commit() session.add(User(name=&quot;James&quot;, age=20, role_id=1)) session.add(User(name=&quot;Wade&quot;, age=40, role_id=2)) session.commit() user = User(name=&quot;Kobe&quot;, age=24, role_id=1) session.add(user) session.commit() # 修改数据 user.name = &quot;Allen&quot; session.merge(user) # 使用merge方法,如果存在则修改,如果不存在则插入 session.query(User).filter(User.id == user.id).update({User.name: &quot;Allen&quot;}) # 使用update方法 session.query(User).filter(User.id == user.id).update({User.age: User.age + 1}) # 使用update方法,自增操作 # 查询数据 roles = session.query(Role) # 返回全部结果 for role in roles: print(&quot;Role:&quot;, role.id, role.name) users = session.query(User) # 返回全部结果 for user in users: print(&quot;User:&quot;, user.id, user.name, user.age, user.role_id) # 其他获取数据的方式 print(&quot;get(id):&quot;, session.query(User).get(1)) # 返回结果集中id为1的项 print(&quot;get[1:3]:&quot;, session.query(User)[1:3]) # 返回结果集中的第2-3项 # 其他高级查询,这里以Users表为例 users = session.query(User).filter(User.id &gt; 6) # 条件查询 users = session.query(User).filter(User.id &gt; 6).all() # 条件查询,返回查询的全部数据 user = session.query(User).filter(User.id &gt; 6).first() # 条件查询,返回查询数据的第一项 users = session.query(User).filter(User.id &gt; 6).limit(10) # 条件查询,返回最多10条数据 users = session.query(User).filter(User.id &gt; 6).offset(2) # 条件查询,从第3条数据开始返回 users = session.query(User).filter(User.id &gt; 6, User.name == &quot;Kobe&quot;) # 条件查询,and操作 users = session.query(User).filter(User.id &gt; 6).filter(User.name == &quot;Kobe&quot;) # 条件查询,and操作 users = session.query(User).filter(sqlalchemy.or_(User.id &gt; 6, User.name == &quot;Kobe&quot;)) # 条件查询,or操作 users = session.query(User).filter(User.id.in_((1, 2))) # 条件查询,in操作 users = session.query(User).filter(sqlalchemy.not_(User.name)) # 条件查询,not操作 user_count = session.query(User.id).count() # 统计全部user的数量 user_count = session.query(sqlalchemy.func.count(User.id)).scalar() # scalar操作返回第一行数据的第一个字段 session.query(sqlalchemy.func.count(&quot;*&quot;)).select_from(User).scalar() # scalar操作返回第一行数据的第一个字段 session.query(sqlalchemy.func.count(1)).select_from(User).scalar() # scalar操作返回第一行数据的第一个字段 session.query(sqlalchemy.func.count(User.id)).filter(User.id &gt; 0).scalar() # filter() 中包含 User，因此不需要指定表 session.query(sqlalchemy.func.sum(User.age)).scalar() # 求和运算,运用scalar函数 session.query(sqlalchemy.func.avg(User.age)).scalar() # 求均值运算,运用scalar函数 session.query(sqlalchemy.func.md5(User.name)).filter(User.id == 1).scalar() # 运用md5函数 users = session.query(sqlalchemy.distinct(User.name)) # 去重查询,根据name进行去重 users = session.query(User).order_by(User.name) # 排序查询,正序查询 users = session.query(User).order_by(User.name.desc()) # 排序查询,倒序查询 users = session.query(User).order_by(sqlalchemy.desc(User.name)) # 排序查询,倒序查询的另外一种形式 users = session.query(User.id, User.name) # 只查询部分属性 users = session.query(User.name.label(&quot;user_name&quot;)) # 结果集的列取别名 for user in users: print(&quot;label test:&quot;, user.user_name) # 这里使用别名 users = session.query(sqlalchemy.func.count(User.name).label(&quot;count&quot;), User.age).group_by(User.age) # 分组查询 for user in users: print(&quot;age:{0}, count:{1}&quot;.format(user.age, user.count)) # 多表查询 result = session.query(User, Role).filter(User.role_id == Role.id) for user, role in result: print(&quot;user %s&apos;s role is %s&quot; % (user.name, role.name)) users = session.query(User).join(Role, User.role_id == Role.id) for user in users: print(&quot;user join, name:&quot;, user.name) # 关联属性的用法 roles = session.query(Role) for role in roles: print(&quot;role:%s users:&quot; % role.name) for user in role.users: print(&quot;\t%s&quot; % user.name) users = session.query(User) for user in users: print(&quot;user %s&apos;s role is %s&quot; % (user.name, user.role.name)) except Exception as excep: session.rollback() raise session.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2017%2F11%2F01%2Ftest.html</url>
    <content type="text"><![CDATA[12test=&quot;(&apos;0&apos;,&apos;!LZX&apos;,&apos;\\x00\\x00\\x00\\x00\\x66\\xe7\\x85\\x47&apos;,&apos;3b58a39341b3e74d93cc7dd083e634d0d5f92779b9d9f5fd64e9a76c49e3167d201ed432c172732f933fff1ad7e35c00b8e5996ded003d87&apos;,&apos;2&apos;)&quot;eval(test) 第三个变了 ‘\’转义符在命令行参数输入中的错误 1sys.path[0] 当前目录 以在app端使用低反爬、高加密保证正常用户的使用，在web端通过高反爬(如ip、访问频率等)、低加密来阻止爬虫。 onclick”属性曝露了处理参数值的函数名称，before_submit, do_encrypt() dism /online /export-driver /destination:D:\MyDrivers Dism /online /Add-Driver /Driver:D:\MyDrivers /Recurse]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 魔法方法]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2FPython%20%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[newnew(cls[, …]) new 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法 new 决定是否要使用该 init 方法，因为 new 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 new 没有返回实例对象，则 init 不会被调用 new 主要是用于继承一个不可变的类型比如一个 tuple 或者 string 魔法方法 魔法方法 含义 init(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 del(self) 析构器，当一个实例被销毁的时候调用的方法 call(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) len(self) 定义当被 len() 调用时的行为 repr(self) 定义当被 repr() 调用时的行为 str(self) 定义当被 str() 调用时的行为 bytes(self) 定义当被 bytes() 调用时的行为 hash(self) 定义当被 hash() 调用时的行为 bool(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False format(self, format_spec) 定义当被 format() 调用时的行为 有关属性 有关属性 getattr(self, name) 定义当用户试图获取一个不存在的属性时的行为 getattribute(self, name) 定义当该类的属性被访问时的行为 setattr(self, name, value) 定义当一个属性被设置时的行为 delattr(self, name) 定义当一个属性被删除时的行为 dir(self) 定义当 dir() 被调用时的行为 get(self, instance, owner) 定义当描述符的值被取得时的行为 set(self, instance, value) 定义当描述符的值被改变时的行为 delete(self, instance) 定义当描述符的值被删除时的行为 比较操作符 比较操作符 lt(self, other) 定义小于号的行为：x &lt; y 调用 x.lt(y) le(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.le(y) eq(self, other) 定义等于号的行为：x == y 调用 x.eq(y) ne(self, other) 定义不等号的行为：x != y 调用 x.ne(y) gt(self, other) 定义大于号的行为：x &gt; y 调用 x.gt(y) ge(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.ge(y) 算数运算符 算数运算符 add(self, other) 定义加法的行为：+ sub(self, other) 定义减法的行为：- mul(self, other) 定义乘法的行为：* truediv(self, other) 定义真除法的行为：/ floordiv(self, other) 定义整数除法的行为：// mod(self, other) 定义取模算法的行为：% divmod(self, other) 定义当被 divmod() 调用时的行为 pow(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 lshift(self, other) 定义按位左移位的行为：&lt;&lt; rshift(self, other) 定义按位右移位的行为：&gt;&gt; and(self, other) 定义按位与操作的行为：&amp; xor(self, other) 定义按位异或操作的行为：^ or(self, other) 定义按位或操作的行为： 反运算 反运算 radd(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rsub(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmul(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rtruediv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rfloordiv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rdivmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rpow(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rlshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rrshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rxor(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） ror(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 增量赋值运算 iadd(self, other) 定义赋值加法的行为：+= isub(self, other) 定义赋值减法的行为：-= imul(self, other) 定义赋值乘法的行为：*= itruediv(self, other) 定义赋值真除法的行为：/= ifloordiv(self, other) 定义赋值整数除法的行为：//= imod(self, other) 定义赋值取模算法的行为：%= ipow(self, other[, modulo]) 定义赋值幂运算的行为：**= ilshift(self, other) 定义赋值按位左移位的行为：&lt;&lt;= irshift(self, other) 定义赋值按位右移位的行为：&gt;&gt;= iand(self, other) 定义赋值按位与操作的行为：&amp;= ixor(self, other) 定义赋值按位异或操作的行为：^= ior(self, other) 定义赋值按位或操作的行为： = 一元操作符 一元操作符 neg(self) 定义正号的行为：+x pos(self) 定义负号的行为：-x abs(self) 定义当被 abs() 调用时的行为 invert(self) 定义按位求反的行为：~x 类型转换 类型转换 complex(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） int(self) 定义当被 int() 调用时的行为（需要返回恰当的值） float(self) 定义当被 float() 调用时的行为（需要返回恰当的值） round(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） index(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理 上下文管理（with 语句） enter(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 | | exit(self, exc_type, exc_value, traceback) | 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 | 容器类型 容器类型 len(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） getitem(self, key) 定义获取容器中指定元素的行为，相当于 self[key] setitem(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value delitem(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] iter(self) 定义当迭代容器中的元素的行为 reversed(self) 定义当被 reversed() 调用时的行为 contains(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为]]></content>
      <tags>
        <tag>魔法方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2F%E8%A3%85%E9%A5%B0%E5%99%A8.html</url>
    <content type="text"><![CDATA[Python 中装饰器的使用import functools 构建不带参数的装饰器def logging(func): @functools.wraps(func) def decorator(*args, **kwargs): print(&quot;%s called&quot; % func.__name__) result = func(*args, **kwargs) print(&quot;%s end&quot; % func.__name__) return result return decorator # 使用装饰器 @logging def test01(a, b): print(&quot;in function test01, a=%s, b=%s&quot; % (a, b)) return 1 # 使用装饰器 @logging def test02(a, b, c=1): print(&quot;in function test02, a=%s, b=%s, c=%s&quot; % (a, b, c)) return 1 构建带参数的装饰器def params_chack(*types, **kwtypes): def _outer(func): @functools.wraps(func) def _inner(*args, **kwargs): result = [isinstance(_param, _type) for _param, _type in zip(args, types)] assert all(result), &quot;params_chack: invalid parameters&quot; result = [isinstance(kwargs[_param], kwtypes[_param]) for _param in kwargs if _param in kwtypes] assert all(result), &quot;params_chack: invalid parameters&quot; return func(*args, **kwargs) return _inner return _outer # 使用装饰器 @params_chack(int, (list, tuple)) def test03(a, b): print(&quot;in function test03, a=%s, b=%s&quot; % (a, b)) return 1 # 使用装饰器 @params_chack(int, str, c=(int, str)) def test04(a, b, c): print(&quot;in function test04, a=%s, b=%s, c=%s&quot; % (a, b, c)) return 1 ## 在类的成员方法中使用装饰器 class ATest(object): @params_chack(object, int, str) def test(self, a, b): print(&quot;in function test of ATest, a=%s, b=%s&quot; % (a, b)) return 1 # 同时使用多个装饰器 @logging @params_chack(int, str, (list, tuple)) def test05(a, b, c): print(&quot;in function test05, a=%s, b=%s, c=%s&quot; % (a, b, c)) return 1 构建不带参数的装饰器类class Decorator(object): def __init__(self, func): self.func = func return def __call__(self, *args, **kwargs): print(&quot;%s called&quot; % self.func.__name__) result = self.func(*args, **kwargs) print(&quot;%s end&quot; % self.func.__name__) return result # 使用装饰器 @Decorator def test06(a, b, c): print(&quot;in function test06, a=%s, b=%s, c=%s&quot; % (a, b, c)) return 1 构建带参数的装饰器类class ParamCheck(object): def __init__(self, *types, **kwtypes): self.types = types self.kwtypes = kwtypes return def __call__(self, func): @functools.wraps(func) def _inner(*args, **kwargs): result = [isinstance(_param, _type) for _param, _type in zip(args, self.types)] assert all(result), &quot;params_chack: invalid parameters&quot; result = [isinstance(kwargs[_param], self.kwtypes[_param]) for _param in kwargs if _param in self.kwtypes] assert all(result), &quot;params_chack: invalid parameters&quot; return func(*args, **kwargs) return _inner # 使用装饰器 @ParamCheck(int, str, (list, tuple)) def test07(a, b, c): print(&quot;in function test06, a=%s, b=%s, c=%s&quot; % (a, b, c)) return 1 ##例子 装饰器实例: 函数缓存def funccache(func): cache = {} @functools.wraps(func) def _inner(*args): if args not in cache: cache[args] = func(*args) return cache[args] return _inner # 使用装饰器 @funccache def test08(a, b, c): # 其他复杂或耗时计算 return a + b + c 使用Python自带的装饰器 @propertyclass People(object): def __init__(self): self._name = None self._age = None return @property def name(self): return self._name @name.setter def name(self, name): self._name = name return @property def age(self): return self._age @age.setter def age(self, age): assert 0 &lt; age &lt; 120 self._age = age return 类静态方法和类方法class Date(object): &quot;&quot;&quot;docstring for Date&quot;&quot;&quot; __slots__ = (&apos;year&apos;,&apos;month&apos;,&apos;day&apos;) def __init__(self, year=0,month=0,day=0): self.year = year self.month = month self.day = day @property def time(self): return &apos;{}-{}-{}&apos;.format(self.year,self.month,self.day) @classmethod def time_from_string(cls,string): year,month,day=string.split(&apos;-&apos;) date = cls(year,month,day) return date @staticmethod def check_time(year,month,day): year,month,day = map(int,[year,month,day]) if 1970&lt;year&lt;2018 and 0&lt;month&lt;13 and 0&lt;day&lt;32: return year, month, day]]></content>
      <tags>
        <tag>装饰器，类静态方法和类方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 多进程与多线程]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2FPython%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[Python 多进程与多线程concurrent1234567import concurrent #进程ProcessPoolExecutordef func(nb): print(str(nb))with concurrent.futures.ThreadPoolExecutor(10) as executor: for arg in list(range(99)): executor.submit(func, arg) tomorrow1234567from tomorrow import threads@threads(10)def func(nb): print(str(nb))for i in range(99): func(i)]]></content>
      <tags>
        <tag>多线程，多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python加解密]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpython%E5%8A%A0%E8%A7%A3%E5%AF%86.html</url>
    <content type="text"><![CDATA[加密hashimport hashlib sha1 = hashlib.sha1() sha1.update(&apos;how to use sha1 in &apos;.encode()) print(sha1.hexdigest()) md5 = hashlib.md5() md5.update(&apos;how to use md5 in&apos;.encode()) print(md5.hexdigest()) base64import base64 base64.b64encode(b&apos;binary\x00string&apos;) base64.b64decode(&apos;YmluYXJ5AHN0cmluZw==&apos;) RSAimport rsa # 生成密钥 (pubkey, privkey) = rsa.newkeys(1024) message = &apos;hello&apos; crypto = rsa.encrypt(message.encode(), pubkey) message = rsa.decrypt(crypto, privkey).decode() print(message) # 签名 signature = rsa.sign(message.encode(), privkey, &apos;SHA-1&apos;) # 公钥验证 rsa.verify(message.encode(), signature, pubkey) rsaPublickey = int(pubkey, 16) key = rsa.PublicKey(rsaPublickey, int(&apos;10001&apos;, 16)) sp = rsa.encrypt(pw.encode(&quot;utf-8&quot;), key) sp = binascii.b2a_hex(sp) AESimport base64 from cryptography.hazmat.primitives import padding from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes from cryptography.hazmat.backends import default_backend key = b&apos;0123456789abcdef&apos; iv = b&apos;0123456789abcdef&apos; text = b&apos;Attack at dawn&apos; # 转pad padder = padding.PKCS7(algorithms.AES.block_size).padder() padded_data = padder.update(text) + padder.finalize() padded_data = padded_data cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend()) encryptor = cipher.encryptor() ct = encryptor.update(padded_data) + encryptor.finalize() ct_base64 = base64.b64encode(ct) print(ct_base64) decryptor = cipher.decryptor() padded_data = decryptor.update(ct) + decryptor.finalize() # 逆转pad unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder() data = unpadder.update(padded_data) text = data + unpadder.finalize() print(text) binasciiimport binascii a = b&apos;worker&apos; c = binascii.hexlify(a) print(c) # 这个功能和a2b_hex()一样 print(binascii.unhexlify(c)) a2b_uu(string) 将以ascii编码的一行数据转化为二进制, 并且返回二进制数据. b2a_uu(data) 将二进制数据转化为一行以ascii编码的字符, date的最大长度为45. a2b_base64(string) 将一块base64的数据转换为二进制数据, 并返回该二进制数据 b2a_base64(string) 与上面相反 a2b_hqx(string) binhex4格式化的ASCII数据转换为二进制, 没有做RLE解压. b2a_hqx(data) 与上相反 rledecode_hqx(data) 按照binhex4标准, 对data执行RLE解压 rlecode_hqx(data) 对data执行binhex方式的压缩, 并返回结果 crc_hqx(data, crc) 计算data的binhex4的crc值 crc32(data[, crc]) 根据crc, 计算crc32(32位检验和数据, 然后将结果 &amp; 0xffffffff(为了在所有Python版本中生成相同的结果, 具体不清楚, 求指导…) a2b_qp(string[, header]) quoted - printable data-&gt;bin, 并返回 b2a_qp(data[, quotetabs, istext, header]) 与上面相反 hexlify(data) 返回二进制数据的16进制的表现形式 unhexlify(hexstr) 与上面相反]]></content>
      <tags>
        <tag>hash,模板rsa,aes,加密,解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arrow时间模块]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Farrow%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[Python 日期处理 arrow时间模块– arrow1234567891011arrow.utcnow()arrow.now()arrow.now(&apos;US/Pacific&apos;)arw=arrow.utcnow()arw.datetimearw.timestamparw.yeararw.time()arw.date()arw.tzinfoarw.naive –arrow.get123456789arrow.get(2013, 5, 5)arrow.get(&apos;2013-05-11T21:23:58.970460+00:00&apos;)arrow.get(&apos;2013-09-30T15:34:00.000-07:00&apos;)arrow.get(&apos;2013-05-05 12:30:45&apos;, &apos;YYYY-MM-DD HH:mm:ss&apos;)arrow.get(&apos;June was born in May 1980&apos;, &apos;MMMM YYYY&apos;)arrow.get(1367900664)arrow.get(1367900664.152325)arrow.get(&apos;1367900664&apos;)arrow.get(&apos;1367900664.152325&apos;) –arrow.format123456local=arrow.now()local.format()local.format(&apos;YYYY-MM-DD HH:mm:ss ZZ&apos;)local.humanize()local.humanize(locale=&apos;ko_kr&apos;)arrow.utcnow().format(&apos;YYYY-MM-DD HH:mm:ss ZZ&apos;) –arrow -change1234567arw = arrow.utcnow()arw.shift(weeks=+3)arw.replace(hour=4, minute=40)arw.replace(weeks=+3)arw.replace(tzinfo=&apos;US/Pacific&apos;)utc.to(&apos;local&apos;)utc.to(&apos;local&apos;).to(&apos;utc&apos;) –arrow -span123arrow.utcnow().span(&apos;hour&apos;)arrow.utcnow().floor(&apos;hour&apos;)arrow.utcnow().ceil(&apos;hour&apos;) –arrow -range12345start = arrow.get(2013, 5, 5, 12, 30)end = arrow.get(2013, 5, 5, 17, 15)for r in arrow.Arrow.span_range(&apos;hour&apos;, start, end): print(r) print(repr(r))]]></content>
      <tags>
        <tag>arrow,时间模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Python 正则表达式 re 模块的使用匹配 后者相反12345678910\d \D 匹配数字\s \S 匹配任意的空白符[ \t\n\r\f\v]\w \W 匹配字母或数字或下划线或汉字\b \B 匹配单词的开始^ $ 匹配字符串的开始\A \Z 匹配开头.匹配除换行符以外的任意字符*+?&#123;m, n&#125; 分别匹配0 - ;1 - ;0 - 1 ;m - n;[^ a] 非a[] #字符集 其他1234&apos;\\&apos; 转义()分组r 转义?非贪婪 re各种方法123456789101112131415161718re.findall(&apos;(?#)abc&apos;, &apos;A\nBc&apos;)pat = re.compile(&apos;(^w+).python.org&apos;) # 编译re.search(pat, text) # 搜索re.match(&apos;(?P&lt;shuzi&gt;a.c)&apos;, &apos;abc&apos;).group(&apos;shuzi&apos;) # 从开头匹配re.findall(pat, text) # listgroup() groups() group(1)text = &apos;a, b,,,,c d&apos;re.split(&apos;[, ]+&apos;, text, maxsplit=2) # MAX=2re.sub(&apos;a&apos;, &apos;b&apos;, &apos;abca&apos;, count=1) # 一次log = &apos;2016-12-01&apos;re.sub(&apos;(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)&apos;, r&apos;\g&lt;day&gt;/\g&lt;month&gt;/\g&lt;year&gt;&apos;, log)pattern = &apos;(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)&apos;m = re.search(pattern, &apos;2016-01-01&apos;)m.groupdict()m.group(&apos;year&apos;)m.group(&apos;month&apos;)m.group(&apos;day&apos;) 捕获&amp;模式捕获捕获(exp) 匹配exp, 并捕获文本到自动命名的组里 (?&lt; name &gt; exp) 匹配exp, 并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp) (?: exp) 匹配exp, 不捕获匹配的文本，也不给此分组分配组号 零宽断言(?=exp) 匹配exp前面的位置 (?&lt;= exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 (? # ...) 注释，不影响正则表达式其它部分,用法参见 模式 I (?(id / name)yes | no) 若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则 (?P=name) 分组的引用模式，可在同一个正则表达式用引用前面命名过的正则 flags 编译时指定的模式re.compile(&apos;&apos;, re.I | re.M | re.S) regex=re.compile(&quot;hello world!&quot;, re.I)MSXU IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改 ^ 和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。 Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符&apos;\n&apos;) IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由 # 标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 X VERBOSE， 此模式忽略正则表达式中的空白和 # 号的注释 例子mail pattern = r&quot;(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)&quot; http pattern = &apos;^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$&apos; ip4 pattern = r&apos;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&apos; ip6 pattern = r&apos;^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$&apos; mac pattern = r&apos;^(?i)([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$&apos; 1.校验密码强度 密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8 - 10之间 &apos;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&apos; 2.校验中文 字符串只能是中文 &apos;^[\\u4e00-\\u9fa5]{0,}$&apos; 3.校验身份证号码 15位： &apos;^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$&apos; 18位： &apos;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$&apos; 4.校验手机号 下面是国内 1358开头的手机号正则表达式 &apos;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$&apos;判断IE的版本 &apos;^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$&apos; 5.提取URL链接 &apos;^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?&apos; 6.文件路径及扩展名校验 &apos;^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$&apos; 7.查找CSS属性 &apos;^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}&apos; 8.抽取注释 &apos;&lt;!--(.*?)--&gt;&apos; 9.匹配HTML标签 &apos;&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s] + ))?) +\\s*|\\s*)\\/?&gt;&apos; 匹配例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731、非负整数：^\d+$ 2、正整数：^[0-9]*[1-9][0-9]*$ 3、非正整数：^((-\d+)|(0+))$ 4、负整数：^-[0-9]*[1-9][0-9]*$ 5、整数：^-?\d+$ 6、非负浮点数：^\d+(\.\d+)?$ 7、正浮点数：^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 8、非正浮点数：^((-\d+\.\d+)?)|(0+(\.0+)?))$ 9、负浮点数：^(-((正浮点数正则式)))$ 10、英文字符串：^[A-Za-z]+$ 11、英文大写串：^[A-Z]+$ 12、英文小写串：^[a-z]+$ 13、英文字符数字串：^[A-Za-z0-9]+$ 14、英数字加下划线串：^\w+$ 15、E-mail地址：^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$ 16、URL：^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$ 或：^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\&apos;:+!]*([^\&quot;\&quot;])*$ 17、邮政编码：^[1-9]\d&#123;5&#125;$ 18、中文：^[\u0391-\uFFE5]+$ 19、电话号码：^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?(\(0\d&#123;2,3&#125;\)|0\d&#123;2,3&#125;-)?[1-9]\d&#123;6,7&#125;(\-\d&#123;1,4&#125;)?$ 20、手机号码：^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?13\d&#123;9&#125;$ 21、双字节字符(包括汉字在内)：^\x00-\xff 22、匹配首尾空格：(^\s*)|(\s*$)（像vbscript那样的trim函数） 23、匹配HTML标记：.*| 24、匹配空行：\n[\s| ]*\r 25、提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\w|\\|\/|\.)+(&apos;|&quot;| *|&gt;)? 26、提取信息中的邮件地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 27、提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\w|\\|\/|\.)+(&apos;|&quot;| *|&gt;)? 28、提取信息中的IP地址：(\d+)\.(\d+)\.(\d+)\.(\d+) 29、提取信息中的中国手机号码：(86)*0*13\d&#123;9&#125; 30、提取信息中的中国固定电话号码：(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125; 31、提取信息中的中国电话号码（包括移动和固定电话）：(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;7,14&#125; 32、提取信息中的中国邮政编码：[1-9]&#123;1&#125;(\d+)&#123;5&#125; 33、提取信息中的浮点数（即小数）：(-?\d*)\.?\d+ 34、提取信息中的任何数字 ：(-?\d*)(\.\d+)? 35、IP：(\d+)\.(\d+)\.(\d+)\.(\d+) 36、电话区号：/^0\d&#123;2,3&#125;$/ 37、腾讯QQ号：^[1-9]*[1-9][0-9]*$ 38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 39、中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$只能输入数字：“^[0-9]*$”只能输入n位的数字：“^d&#123;n&#125;$”只能输入至少n位数字：“^d&#123;n,&#125;$”只能输入m-n位的数字：“^d&#123;m,n&#125;$”只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”只能输入有两位小数的正实数：“^[0-9]+(.[0-9]&#123;2&#125;)?$”只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]&#123;1,3&#125;)?$”只能输入非零的正整数：“^+?[1-9][0-9]*$”只能输入非零的负整数：“^-[1-9][0-9]*$”只能输入长度为3的字符：“^.&#123;3&#125;$”只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”验证用户密码:“^[a-zA-Z]w&#123;5,17&#125;$”正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;&apos;,;=?$x22]+”只能输入汉字：“^[u4e00-u9fa5],&#123;0,&#125;$”验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$”验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$”验证电话号码：“^((d&#123;3,4&#125;)|d&#123;3,4&#125;-)?d&#123;7,8&#125;$”正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。验证身份证号（15位或18位数字）：“^d&#123;15&#125;|d&#123;&#125;18$”验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”]]></content>
      <tags>
        <tag>正则表达式,re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda & pip]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fconda%20%26%20pip.html</url>
    <content type="text"><![CDATA[conda &amp; pip简单的使用执行python -m venv myenv1即可创建虚拟环境myenv1 *nix系统下，使用命令pyvenv。 Windows下命令行myenv1\Scripts\activate.bat进入环境， 使用deactivate退出虚拟环境。 管理软件# 将anaconda的bin目录加入PATH，根据版本不同，也可能是~/anaconda3/bin echo &apos;export PATH=&quot;~/anaconda2/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc # 更新bashrc以立即生效 source ~/.bashrc # 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本） conda create --name python34 python=3.4 # conda create -n bunnies python=3 Astroid Babel # conda info -envis # 安装好后，使用activate激活某个环境 activate python34 # for Windows source activate python34 # for Linux &amp; Mac # 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH # 此时，再次输入 python --version # 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境 # 如果想返回默认的python 2.7环境，运行 deactivate python34 # for Windows source deactivate python34 # for Linux &amp; Mac # 删除一个已有的环境 conda remove --name python34 --all # 通过克隆来复制一个环境。这儿将通过克隆snowfllakes来创建一个称为flowers的副本。 conda create -n flowers --clone snowflakes # 安装scipy conda install scipy # conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库） # 查看当前环境下已安装的包 conda list # 查看某个指定环境的已安装包 conda list -n python34 # 查找package信息 conda search numpy # 安装package conda install -n python34 numpy # 如果不用-n指定环境名称，则被安装在当前活跃环境 # 也可以通过-c指定通过某个channel安装 # 更新package conda update -n python34 numpy # 删除package conda remove -n python34 numpy # 更新conda，保持conda最新 conda update conda # 更新anaconda conda update anaconda # 更新python conda update python # 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 # 在当前环境下安装anaconda包集合 conda install anaconda # 结合创建环境的命令，以上操作可以合并为 conda create -n python34 python=3.4 anaconda # 也可以不用全部安装，根据需求安装自己需要的package即可 # 添加Anaconda的TUNA镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ # 设置搜索时显示通道地址 conda config --set show_channel_urls yes 改源linuxlinux下运行命令 vi ~/.pip/pip.conf 然后写入如下内容并保存 [global] trusted-host = mirrors.aliyun.com index-url = http://mirrors.aliyun.com/pypi/simple Windowsimport os ini = &quot;[global]\nindex-url = https://pypi.doubanio.com/simple/\n&quot; pippath = os.environ[&quot;USERPROFILE&quot;]+&quot;\\pip\\&quot; exec(&quot;if not os.path.exists(pippath):\n\tos.mkdir(pippath)&quot;) open(pippath+&quot;/pip.ini&quot;, &quot;w+&quot;).write(ini) pippip install SomePackage＃最新版本 pip install SomePackage == 1.0.4＃具体版本 pip install&apos;SomePackage&gt; = 1.0.4&apos;＃最小版本 pip install --upgrade SomePackage pip download SomePackage show list search uninstall # 导出当前已经安装包 pip freeze &gt; requirements.txt pip install -r requirements.txt]]></content>
      <tags>
        <tag>环境搭建,pip,conda,改源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipython]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fipython.html</url>
    <content type="text"><![CDATA[ipython基本使用. % run命令 ipython - -pylab Tab键 内省? 快捷键Ctrl - P 或上箭头键 后向搜索命令历史中以当前输入的文本开头的命令 Ctrl - N 或下箭头键 前向搜索命令历史中以当前输入的文本开头的命令 Ctrl - R 按行读取的反向历史搜索（部分匹配） Ctrl - Shift - v 从剪贴板粘贴文本 Ctrl - C 中止当前正在执行的代码 Ctrl - A 将光标移动到行首 Ctrl - E 将光标移动到行尾 Ctrl - K 删除从光标开始至行尾的文本 Ctrl - U 清除当前行的所有文本译注12 Ctrl - F 将光标向前移动一个字符 Ctrl - b 将光标向后移动一个字符 Ctrl - L 清屏 魔法%quickref 显示IPython的快速参考 %magic 显示所有魔术命令的详细文档 %debug 从最新的异常跟踪的底部进入交互式调试器 %hist 打印命令的输入（可选输出）历史 %pdb 在异常发生后自动进入调试器 %paste 执行剪贴板中的Python代码 %cpaste 打开一个特殊提示符以便手工粘贴待执行的Python代码 %reset 删除interactive命名空间中的全部变量 / 名称 %page OBJECT 通过分页器打印输出OBJECT %run script.py 在IPython中执行一个Python脚本文件 %prun statement 通过cProfile执行statement，并打印分析器的输出结果 %time statement 报告statement的执行时间 %timeit statement 多次执行statement以计算系综平均执行时间。对那些执行时 间非常小的代码很有用 %who、% who_ls、% whos 显示interactive命名空间中定义的变量，信息级别 / 冗余度可变 %xdel variable 删除variable，并尝试清除其在IPython中的对象上的一切引用 搜索并重用命令历史上箭头键：搜索出命令历史中第一个与你输入的字符相匹配的命令。多次按将会在历史中不断搜索。 下箭头键：子命令历史中向前搜索。 Ctrl - R：部分增量搜素，循环在命令历史中搜素与输入相符的行。 输入和输出变量%hist 打印输入历史 %reset 清空interactive命名空间，可选择是否清空输入和输出缓存 %xdel 从IPython中移除特定对象的一切引用 记录输入和输出执行 % logstart能够开始记录控制台回话，包括输入和输出。与之配合的命令有：% logoff、% logon、% logstate、% logstop 与系统相关的命令：!cmd 在系统shell中执行cmd output =!cmd args 执行cmd，并将结果放在output中 %bookmark 使用IPython的目录书签系统 %cd directory 更改工作目录 %pwd 返回系统当前工作目录 %env 以字典形式返回系统环境变量 shell在IPython中以感叹号(!)开头的命令表示其后的所有内容将会在系统shell中执行。 使用！时，还允许使用当前环境中定义的Python值，只需在变量名前加上美元($)符号即可： foo = &apos;54678&apos; !mkdir $foo 书签%bookmark pys &apos;C:/User/xxx/PyWorkSpace&apos; 定义好书签之后，就可以在执行魔术命令 % cd时使用这些书签了： cd pys 列出所有书签： %bookmark - l 书签名与目录冲突 %bookmark - b pys # 强制使用书签目录]]></content>
      <tags>
        <tag>ipython,快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logging]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Flogging.html</url>
    <content type="text"><![CDATA[logging使用import logging # 创建一个logger logger = logging.getLogger(&apos;mylogger&apos;) logger.setLevel(logging.DEBUG) # 创建一个handler，用于写入日志文件 fh = logging.FileHandler(&apos;d://test.log&apos;) fh.setLevel(logging.DEBUG) # 再创建一个handler，用于输出到控制台 ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # 定义handler的输出格式 formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;) fh.setFormatter(formatter) ch.setFormatter(formatter) # 给logger添加handler logger.addHandler(fh) logger.addHandler(ch) # 记录一条日志 logger.info(&apos;foorbar&apos;) 导入配置import logging from logging.config import dictConfig logging_config = dict( version = 1, formatters = { &apos;f&apos;: {&apos;format&apos;: &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;} }, handlers = { &apos;h&apos;: {&apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;f&apos;, &apos;level&apos;: logging.DEBUG} }, loggers = { &apos;root&apos;: {&apos;handlers&apos;: [&apos;h&apos;], &apos;level&apos;: logging.DEBUG} } ) dictConfig(logging_config) logger = logging.getLogger() logger.debug(&apos;often makes a very good meal of %s&apos;, &apos;visiting tourists&apos;) logging基本配置import logging # 创建一个log.log日志文件 logging.basicConfig(filename=&apos;d:\\log.log&apos;, # 格式化的字符串 format=&apos;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&apos;, # 时间 datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;, # 错误级别 level=logging.DEBUG ) filemode=&apos;a&apos; logging.critical(&apos;critical&apos;) logging.error(&apos;error&apos;) logging.warning(&apos;warning&apos;) logging.info(&apos;info&apos;) logging.debug(&apos;debug&apos;) logging.log(logging.INFO, &apos;NOTSET&apos;)]]></content>
      <tags>
        <tag>log,logging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册表 pyregedit]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2F%E6%B3%A8%E5%86%8C%E8%A1%A8%20pyregedit.html</url>
    <content type="text"><![CDATA[注册表 pyregeditpyregeditimport win32api import win32con import os # 权限设置 REG_FLAGS = win32con.WRITE_OWNER | win32con.KEY_WOW64_64KEY | win32con.KEY_ALL_ACCESS #root (根节点) HKEY_CLASSES_ROOT = win32con.HKEY_CLASSES_ROOT HKEY_CURRENT_USER = win32con.HKEY_CURRENT_USER HKEY_LOCAL_MACHINE = win32con.HKEY_LOCAL_MACHINE HKEY_USERS = win32con.HKEY_USERS HKEY_CURRENT_CONFIG = win32con.HKEY_CURRENT_CONFIG # value type (值类型) REG_SZ = win32con.REG_SZ REG_BINARY = win32con.REG_BINARY REG_DWORD = win32con.REG_DWORD REG_QWORD = win32con.REG_QWORD REG_MULTI_SZ = win32con.REG_MULTI_SZ REG_EXPAND_SZ = win32con.REG_EXPAND_SZ class RegEdit(): def __init__(self, root, path): &quot;&quot;&quot;init method (key root, key path)&quot;&quot;&quot; self.root = root self.path = path # 判断键是否存在 def check_key(self): &quot;&quot;&quot;check key is exist or not&quot;&quot;&quot; try: key = self.get_key() key.close() return True except Exception as e: return False # 获取键 def get_key(self): &quot;&quot;&quot;get key object&quot;&quot;&quot; key = win32api.RegOpenKeyEx(self.root, self.path, 0, REG_FLAGS) return key # 获取子键名称 def get_sub_keys(self): &quot;&quot;&quot;get key&apos;s sub keys&quot;&quot;&quot; key = self.get_key() for item in win32api.RegEnumKeyEx(key): yield item[0] key.close() # 获取全部值 def get_values(self): &quot;&quot;&quot;get key&apos;s values&quot;&quot;&quot; key = self.get_key() try: i = 0 while True: # 循环枚举值 yield win32api.RegEnumValue(key, i) i += 1 except Exception as e: pass finally: key.close() # 根据名称获取值 def get_value(self, value_name): &quot;&quot;&quot;get value by name&quot;&quot;&quot; key = self.get_key() value, value_type = win32api.RegQueryValueEx(key, value_name) return value, value_type # 创建键 def create_key(self): &quot;&quot;&quot;create and return a key&quot;&quot;&quot; key, _ = win32api.RegCreateKeyEx(self.root, self.path, REG_FLAGS) return key # 创建子键 def create_sub_key(self, sub_key_name): &quot;&quot;&quot;create a sub key&quot;&quot;&quot; sub_key_path = os.path.join(self.path, sub_key_name) sub_key, _ = win32api.RegCreateKeyEx( self.root, sub_key_path, REG_FLAGS) return sub_key # 创建值 def create_value(self, value_name, value_type=REG_SZ, value_value=&apos;&apos;): &quot;&quot;&quot;create value&quot;&quot;&quot; key = self.create_key() win32api.RegSetValueEx(key, value_name, 0, value_type, value_value) key.close() return True # 删除当前键 def delete_current_key(self): &quot;&quot;&quot;delete current key&quot;&quot;&quot; parent, key_name = os.path.split(self.path) key_parent = win32api.RegOpenKeyEx(self.root, parent, 0, REG_FLAGS) win32api.RegDeleteKeyEx(key_parent, key_name) key_parent.close() return True # 删除子键 def delete_sub_key(self, sub_key_name): &quot;&quot;&quot;delete sub key&quot;&quot;&quot; key = self.get_key() win32api.RegDeleteKeyEx(key, sub_key_name) key.close() return True # 删除值 def delete_value(self, value_name): &quot;&quot;&quot;delete a value item&quot;&quot;&quot; key = self.get_key() win32api.RegDeleteValue(key, value_name) key.close() return True 操作import pyregedit root = pyregedit.HKEY_LOCAL_MACHINE path = r&quot;SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\0002&quot; reg = pyregedit.RegEdit(root, path) #判断键是否存在 if reg.check_key(): #获取键(可用于其他操作) key = reg.get_key() else: #创建键 key = reg.create_key() #创建值 reg.create_value(&apos;NetworkAddress&apos;, pyregedit.REG_SZ, &apos;020E2637D888&apos;) #创建子键 reg.create_sub_key(&apos;sub_test&apos;) #获取子键名称列表 print(list(reg.get_sub_keys())) #获取全部值 print(list(reg.get_values())) #根据具体名称获取某个值的数据 print(reg.get_value(&apos;NetworkAddress&apos;)) #删除值 reg.delete_value(&apos;test_name&apos;) #删除子键 reg.delete_sub_key(&apos;sub_test&apos;) #删除当前键 reg.delete_curretn_key() 改macimport random def randomMAC(): mac = [ 0x52, 0x54, 0x00, random.randint(0x00, 0x7f), random.randint(0x00, 0xff), random.randint(0x00, 0xff) ] return &apos;&apos;.join(map(lambda x: &quot;%02x&quot; % x, mac)).upper() import pyregedit root = pyregedit.HKEY_LOCAL_MACHINE path = r&quot;SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\0002&quot; reg = pyregedit.RegEdit(root, path) mac=randomMAC() #创建值 reg.create_value(&apos;NetworkAddress&apos;, pyregedit.REG_SZ, mac) print(reg.get_value(&apos;NetworkAddress&apos;)) import shutil shutil.rmtree(r&apos;C:\Users\Administrator\AppData\Roaming\Lantern&apos;) print (&apos;ok&apos;) import requests r=requests.get(&apos;http://192.168.0.1/goform/SysToolReboot&apos;,timeout=4)]]></content>
      <tags>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pythonic]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpythonic.html</url>
    <content type="text"><![CDATA[一行代码# 一行代码实现变量值互换 a, b = 1, 2; a, b = b, a # 一行代码解决FizzBuzz问题: 打印数字1到100, 3的倍数打印“Fizz”来替换这个数, 5的倍数打印“Buzz”, 既是3又是5的倍数的打印“FizzBuzz” print(&apos; &apos;.join([&quot;fizz&quot;[x % 3 * 4:]+&quot;buzz&quot;[x % 5 * 4:] or str(x) for x in range(1, 101)])) # 一行代码输出特定字符&quot;Love&quot;拼成的心形 print(&apos;\n&apos;.join([&apos;&apos;.join([(&apos;Love&apos;[(x-y) % len(&apos;Love&apos;)] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &lt;= 0 else &apos; &apos;) for x in range(-30, 30)]) for y in range(30, -30, -1)])) # 一行代码输出Mandelbrot图像: Mandelbrot图像中的每个位置都对应于公式N=x+y*i中的一个复数 print(&apos;\n&apos;.join([&apos;&apos;.join([&apos;*&apos;if abs((lambda a: lambda z, c, n: a(a, z, c, n))(lambda s, z, c, n: z if n == 0 else s(s, z*z+c, c, n-1))(0, 0.02*x+0.05j*y, 40)) &lt; 2 else &apos; &apos; for x in range(-80, 20)]) for y in range(-20, 20)])) # 一行代码打印九九乘法表 print(&apos;\n&apos;.join([&apos; &apos;.join([&apos;%s*%s=%-2s&apos; % (y, x, x*y) for y in range(1, x+1)]) for x in range(1, 10)])) # 一行代码计算出1-100之间的素数(两个版本) print(&apos; &apos;.join([str(item) for item in filter(lambda x: not [x % i for i in range(2, x) if x % i == 0], range(2, 101))])) print(&apos; &apos;.join([str(item) for item in filter(lambda x: all(map(lambda p: x % p != 0, range(2, x))), range(2, 101))])) # 一行代码输出斐波那契数列 print([x[0] for x in [(a[i][0], a.append([a[i][1], a[i][0]+a[i][1]])) for a in ([[1, 1]], ) for i in range(30)]]) # 一行代码实现快排算法 qsort = lambda arr: len(arr) &gt; 1 and qsort(list(filter(lambda x: x &lt;= arr[0], arr[1:]))) + arr[0:1] + qsort(list(filter(lambda x: x &gt; arr[0], arr[1:]))) or arr # 一行代码解决八皇后问题 [__import__(&apos;sys&apos;).stdout.write(&apos;\n&apos;.join(&apos;.&apos; * i + &apos;Q&apos; + &apos;.&apos; * (8-i-1) for i in vec) + &quot;\n========\n&quot;) for vec in __import__(&apos;itertools&apos;).permutations(range(8)) if 8 == len(set(vec[i]+i for i in range(8))) == len(set(vec[i]-i for i in range(8)))] # 一行代码实现数组的flatten功能: 将多维数组转化为一维 flatten = lambda x: [y for l in x for y in flatten(l)] if isinstance(x, list) else [x] # 一行代码实现list, 有点类似与上个功能的反功能 array = lambda x: [x[i:i+3] for i in range(0, len(x), 3)] # 一行代码实现求解2的1000次方的各位数之和 print(sum(map(int, str(2**1000)))) with# 内置库contextlib的使用 @contextlib.contextmanager def open_func(file_name): # __enter__方法 print(&quot;open file:&quot;, file_name, &quot;in __enter__&quot;) file_handler = open(file_name, &quot;r&quot;) yield file_handler # __exit__方法 print(&quot;close file:&quot;, file_name, &quot;in __exit__&quot;) file_handler.close() return # 使用实例 with open_func(&quot;python_base.py&quot;) as file_in: for line in file_in: print(line) break # 内置库contextlib的使用 class MyOpen2(object): def __init__(self, file_name): &quot;&quot;&quot;初始化方法&quot;&quot;&quot; self.file_handler = open(file_name, &quot;r&quot;) return def close(self): &quot;&quot;&quot;关闭文件，会被自动调用&quot;&quot;&quot; print(&quot;call close in MyOpen2&quot;) if self.file_handler: self.file_handler.close() return # 使用实例 with contextlib.closing(MyOpen2(&quot;python_base.py&quot;)) as file_in: pass]]></content>
      <tags>
        <tag>with,一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2F%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[函数from operator import add import operator as op from functools import partial, reduce # 列表解析 a_list = [item**2 for item in range(5)] print(a_list) # 字典解析 a_dict = {&quot;%d^2&quot; % item: item**2 for item in range(5)} print(a_dict) # 生成器 a_generator = (item**2 for item in range(5)) print(a_generator) print(next(a_generator)) print(next(a_generator)) # iter函数和next函数 a_list_generator = iter(a_list) print(next(a_list_generator)) print(next(a_list_generator)) print(type(a_list), type(a_list_generator)) # lambda表达式 a_func = lambda x, y: x**y print(a_func(2, 3)) # map函数 print(map(abs, range(-4, 5))) print(list(map(abs, range(-4, 5)))) print(list(map(lambda x: x**2, range(5)))) print(list(map(lambda x, y: x**y, range(1, 5), range(1, 5)))) print(list(map(pow, [3, 4, 5], [1, 2, 3]))) # reduce函数 print(reduce(lambda x, y: x + y, range(10))) print(reduce(lambda x, y: x + y, range(10), 100)) print(reduce(lambda x, y: x + y, [[1, 2], [3, 4]], [0])) # filter函数 print(filter(None, range(-4, 5))) print(list(filter(None, range(-4, 5)))) print(list(filter(lambda x: x &gt; 0, range(-4, 5)))) # all、any函数 print(all([0, 1, 2])) print(any([0, 1, 2])) # enumerate函数 for index, item in enumerate(range(5)): print(&quot;%d: %d&quot; % (index, item)) # zip函数 for a, b in zip([1, 2, 3], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]): print(a, b) a_dict = dict(zip([1, 2, 3], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])) print(a_dict) # partial函数 print(int(&quot;10010&quot;, base=2)) int_base_2 = partial(int, base=2) print(int_base_2(&quot;10010&quot;)) # operator.add函数 print(reduce(lambda x, y: x + y, range(10))) print(reduce(add, range(10))) # operator def print_table(operator): for x in range(1, 3): for y in range(1, 3): print(str(operator(x, y)) + &apos;\n&apos;) for operator in (op.add, op.sub, op.mul, op.truediv): print_table(operator) from functools import partial blocks = [] for block in iter(partial(f.read, 32), &apos;&apos;): blocks.append(block)]]></content>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2F%E5%8D%8F%E7%A8%8B.html</url>
    <content type="text"><![CDATA[协程import asyncio import aiohttp import threading # 生产者、消费者例子 def consumer(): # 定义消费者，由于有yeild关键词，此消费者为一个生成器 print(&quot;[Consumer] Init Consumer ......&quot;) r = &quot;init ok&quot; # 初始化返回结果，并在启动消费者时，返回给生产者 while True: n = yield r # 消费者通过yield关键词接收生产者产生的消息，同时返回结果给生产者 print(&quot;[Consumer] conusme n = %s, r = %s&quot; % (n, r)) r = &quot;consume %s OK&quot; % n # 消费者消费结果，下个循环返回给生产者 def produce(c): # 定义生产者，此时的 c 为一个生成器 print(&quot;[Producer] Init Producer ......&quot;) r = c.send(None) # 启动消费者生成器，同时第一次接收返回结果 print(&quot;[Producer] Start Consumer, return %s&quot; % r) n = 0 while n &lt; 5: n += 1 print(&quot;[Producer] While, Producing %s ......&quot; % n) r = c.send(n) # 向消费者发送消息，同时准备接收结果。此时会切换到消费者执行 print(&quot;[Producer] Consumer return: %s&quot; % r) c.close() # 关闭消费者生成器 print(&quot;[Producer] Close Producer ......&quot;) # produce(consumer()) # 异步IO例子：适配Python3.4，使用asyncio库 @asyncio.coroutine def hello(index): # 通过装饰器asyncio.coroutine定义协程 print(&apos;Hello world! index=%s, thread=%s&apos; % (index, threading.currentThread())) yield from asyncio.sleep(1) # 模拟IO任务 print(&apos;Hello again! index=%s, thread=%s&apos; % (index, threading.currentThread()))@asyncio.coroutine loop = asyncio.get_event_loop() # 得到一个事件循环模型 tasks = [hello(1), hello(2)] # 初始化任务列表 loop.run_until_complete(asyncio.wait(tasks)) # 执行任务 loop.close() # 关闭事件循环列表 # 异步IO例子：适配Python3.5，使用async和await关键字 async def hello1(index): # 通过关键字async定义协程 print(&apos;Hello world! index=%s, thread=%s&apos; % (index, threading.currentThread())) await asyncio.sleep(1) # 模拟IO任务 print(&apos;Hello again! index=%s, thread=%s&apos; % (index, threading.currentThread())) loop = asyncio.get_event_loop() # 得到一个事件循环模型 tasks = [hello1(1), hello1(2)] # 初始化任务列表 loop.run_until_complete(asyncio.wait(tasks)) # 执行任务 loop.close() # 关闭事件循环列表 # aiohttp 实例 async def get(url): async with aiohttp.ClientSession() as session: async with session.get(url) as resp: print(url, resp.status) print(url, await resp.text()) loop = asyncio.get_event_loop() # 得到一个事件循环模型 tasks = [ # 初始化任务列表 get(&quot;http://zhushou.360.cn/detail/index/soft_id/3283370&quot;), get(&quot;http://zhushou.360.cn/detail/index/soft_id/3264775&quot;), get(&quot;http://zhushou.360.cn/detail/index/soft_id/705490&quot;) ] loop.run_until_complete(asyncio.wait(tasks)) # 执行任务 loop.close() # 关闭事件循环列表]]></content>
      <tags>
        <tag>协程,异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pep8]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpep8.html</url>
    <content type="text"><![CDATA[pep8命名lowercase 小写字母 lower_case_with_underscores 使用下划线分隔的小写字母 UPPERCASE 大写字母 UPPER_CASE_WITH_UNDERSCORES 使用下划线分隔的大写字母 CapitalizedWords 类名: CamelCase ，缩写词大写（ HTTPWriter 而非 HttpWriter ） 变量名: lowercase_with_underscores 方法和函数名: lowercase_with_underscores 常量: UPPERCASE_WITH_UNDERSCORES 预编译正则表达式: name_re 比如：day_of_week, hosts_to_reboot, expired_cards 比如：port（端口号）、age（年龄）、radius（半径） 等等 比如：user_id、host_id 比如：length_of_username、max_length、users_count is_superuser： 『是否超级用户』，只会有两种值：是 / 不是 has_error： 『有没有错误』，只会有两种值：有 / 没有 allow_vip： 『是否允许 VIP』，只会有两种值：允许 / 不允许 use_msgpack： 『是否使用 msgpack』，只会有两种值：使用 / 不使用 debug： 『是否开启调试模式』，被当做 bool 主要是因为约定俗成 异常名中使用后缀&quot;Error&quot; dont: 相似的变量名，比如同时出现 users、users1、 user3 这种序列 不要使用带否定含义的变量名，用 is_special 代替 is_not_normal 永远不要用字符&apos;l&apos;, &apos;O&apos;, 或&apos;I&apos;作为单字符的变量名. 空格/空行在 list, dict, tuple, set, 参数列表的, 后面加一个空格 在 dict 的: 后面加一个空格 在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格 操作符两端加一个空格，如 + , -, *, / , | , &amp; , = 接上一条，在参数列表里的 = 两端不需要空格 括号（(), {}, []）内的两端不需要空格 function 和 class 顶上两个空行 class 的 method 之间一个空行 函数内逻辑无关的段落之间空一行，不要过度使用空行 不要把多个语句写在一行，然后用 隔开 if / for / while 语句中，即使执行语句只有一句，也要另起一行 最大行长度限制所有行最多79个字符。 income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 折叠长行的首选方法是使用Pyhon支持的圆括号, 方括号(brackets)和花括号(braces) 反斜杠\ a = &apos;1&apos; + &apos;2&apos; + &apos;3&apos; + \ &apos;4&apos; + &apos;5&apos; 或者 a = (&apos;1&apos; + &apos;2&apos; + &apos;3&apos; + &apos;4&apos; + &apos;5&apos;) 导入import os import sys from subprocess import Popen, PIPE from sound.effects import echo 文档# 因为某种原因这个函数减慢程序执行。 def foo(): &quot;&quot;&quot;This is a simple docstring&quot;&quot;&quot; def bar(): &quot;&quot;&quot;This is a longer docstring with so much information in there that it spans three lines. In this case the closing triple quote is on its own line. &quot;&quot;&quot;]]></content>
      <tags>
        <tag>pep8,命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpython%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[python基础类型和运算寻求帮助:dir(obj) # 简单的列出对象obj所包含的方法名称，返回一个字符串列表 help(obj.func) # 查询obj.func的具体介绍和用法 测试类型的三种方法，推荐第三种if type(L) == type([]): print(&quot;L is list&quot;) if type(L) == list: print(&quot;L is list&quot;) if isinstance(L, list): print(&quot;L is list&quot;) Python数据类型：哈希类型、不可哈希类型# 哈希类型，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看其hash值，也可以作为字典的key &quot;数字类型：int, float, decimal.Decimal, fractions.Fraction, complex&quot; &quot;字符串类型：str, bytes&quot; &quot;元组：tuple&quot; &quot;冻结集合：frozenset&quot; &quot;布尔类型：True, False&quot; &quot;None&quot; # 不可hash类型：原地可变类型：list、dict和set。它们不可以作为字典的key。 数字常量1234, -1234, 0, 999999999 # 整数 1.23, 1., 3.14e-10, 4E210, 4.0e+210 # 浮点数 0o177, 0x9ff, 0X9FF, 0b101010 # 八进制、十六进制、二进制数字 3+4j, 3.0+4.0j, 3J # 复数常量，也可以用complex(real, image)来创建 hex(I), oct(I), bin(I) # 将十进制数转化为十六进制、八进制、二进制表示的“字符串” int(string, base) # 将字符串转化为整数，base为进制数 # 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数 float(&apos;inf&apos;), float(&apos;-inf&apos;), float(&apos;nan&apos;) # 无穷大, 无穷小, 非数 数字的表达式操作符yield x # 生成器函数发送协议 lambda args: expression # 生成匿名函数 x if y else z # 三元选择表达式 x and y, x or y, not x # 逻辑与、逻辑或、逻辑非 x in y, x not in y # 成员对象测试 x is y, x is not y # 对象实体测试 x&lt;y, x&lt;=y, x&gt;y, x&gt;=y, x==y, x!=y # 大小比较，集合子集或超集值相等性操作符 1 &lt; a &lt; 3 # Python中允许连续比较 x|y, x&amp;y, x^y # 位或、位与、位异或 x&lt;&lt;y, x&gt;&gt;y # 位操作：x左移、右移y位 +, -, *, /, //, %, ** # 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算 -x, +x, ~x # 一元减法、识别、按位求补（取反） x[i], x[i:j:k] # 索引、分片、调用 int(3.14), float(3) # 强制类型转换 整数可以利用bit_length函数测试所占的位数a = 1; a.bit_length() # 1 a = 1024; a.bit_length() # 11 repr和str显示格式的区别&quot;&quot;&quot; repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。 str格式：打印语句，转化成一种对用户更加友好的格式。 &quot;&quot;&quot; 数字相关的模块# Decimal模块：小数模块 import decimal from decimal import Decimal Decimal(&quot;0.01&quot;) + Decimal(&quot;0.02&quot;) # 返回Decimal(&quot;0.03&quot;) decimal.getcontext().prec = 4 # 设置全局精度为4 即小数点后边4位 # Fraction模块：分数模块 from fractions import Fraction x = Fraction(4, 6) # 分数类型 4/6 x = Fraction(&quot;0.25&quot;) # 分数类型 1/4 接收字符串类型的参数 集合set&quot;&quot;&quot; set是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。 set支持union(联合), intersection(交), difference(差)和symmetric difference(对称差集)等数学运算。 set支持x in set, len(set), for x in set。 set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作 &quot;&quot;&quot; s = set([3,5,9,10]) # 创建一个数值集合，返回{3, 5, 9, 10} t = set(&quot;Hello&quot;) # 创建一个唯一字符的集合返回{} a = t | s; t.union(s) # t 和 s的并集 b = t &amp; s; t.intersection(s) # t 和 s的交集 c = t – s; t.difference(s) # 求差集（项在t中, 但不在s中） d = t ^ s; t.symmetric_difference(s) # 对称差集（项在t或s中, 但不会同时出现在二者中） t.add(&apos;x&apos;); t.remove(&apos;H&apos;) # 增加/删除一个item s.update([10,37,42]) # 利用[......]更新s集合 x in s, x not in s # 集合中是否存在某个值 s.issubset(t); s &lt;= t # 测试是否 s 中的每一个元素都在 t 中 s.issuperset(t); s &gt;= t # 测试是否 t 中的每一个元素都在 s 中 s.copy(); s.discard(x); # 删除s中x s.clear() # 清空s {x**2 for x in [1, 2, 3, 4]} # 集合解析，结果：{16, 1, 4, 9} {x for x in &apos;spam&apos;} # 集合解析，结果：{&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;m&apos;} 集合frozenset，不可变对象&quot;&quot;&quot; set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的) frozenset是不可变对象，即存在hash值，可作为字典的键值 frozenset对象没有add、remove等方法，但有union/intersection/difference等方法 &quot;&quot;&quot; a = set([1, 2, 3]) b = set() b.add(a) # error: set是不可哈希类型 b.add(frozenset(a)) # ok，将set变为frozenset，可哈希 布尔类型booltype(True) # 返回&lt;class &apos;bool&apos;&gt; isinstance(False, int) # bool类型属于整型，所以返回True True == 1; True is 1 # 输出(True, False) 动态类型简介&quot;&quot;&quot; 变量名通过引用，指向对象。 Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如&quot;类型标示符&quot; &quot;引用计数器&quot;等 &quot;&quot;&quot; #共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！ #共享引用和相等测试： L = [1], M = [1], L is M # 返回False L = M = [1, 2, 3], L is M # 返回True，共享引用 #增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改 L = M = [1, 2] L = L + [3, 4] # L = [1, 2, 3, 4], M = [1, 2] L += [3, 4] # L = [1, 2, 3, 4], M = [1, 2, 3, 4] 常见字符串常量和表达式S = &apos;&apos; # 空字符串 S = &quot;spam’s&quot; # 双引号和单引号相同 S = &quot;s\np\ta\x00m&quot; # 转义字符 S = &quot;&quot;&quot;spam&quot;&quot;&quot; # 三重引号字符串，一般用于函数说明 S = r&apos;\temp&apos; # Raw字符串，不会进行转义，抑制转义 S = b&apos;Spam&apos; # Python3中的字节字符串 S = u&apos;spam&apos; # Python2.6中的Unicode字符串 s1+s2, s1*3, s[i], s[i:j], len(s) # 字符串操作 &apos;a %s parrot&apos; % &apos;kind&apos; # 字符串格式化表达式 &apos;a {1} {0} parrot&apos;.format(&apos;kind&apos;, &apos;red&apos;)# 字符串格式化方法 for x in s: print(x) # 字符串迭代，成员关系 [x*2 for x in s] # 字符串列表解析 &apos;,&apos;.join([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) # 字符串输出，结果：a,b,c 内置str处理函数：str1 = &quot;stringobject&quot; str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title() # 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写 str1.ljust(width) # 获取固定长度，左对齐，右边不够用空格补齐 str1.rjust(width) # 获取固定长度，右对齐，左边不够用空格补齐 str1.center(width) # 获取固定长度，中间对齐，两边不够用空格补齐 str1.zfill(width) # 获取固定长度，右对齐，左边不足用0补齐 str1.find(&apos;t&apos;,start,end) # 查找字符串，可以指定起始及结束位置搜索 str1.rfind(&apos;t&apos;) # 从右边开始查找字符串 str1.count(&apos;t&apos;) # 查找字符串出现的次数 #上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1 str1.replace(&apos;old&apos;,&apos;new&apos;) # 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new str1.strip(); # 默认删除空白符 str1.strip(&apos;d&apos;); # 删除str1字符串中开头、结尾处，位于 d 删除序列的字符 str1.lstrip(); str1.lstrip(&apos;d&apos;); # 删除str1字符串中开头处，位于 d 删除序列的字符 str1.rstrip(); str1.rstrip(&apos;d&apos;) # 删除str1字符串中结尾处，位于 d 删除序列的字符 str1.startswith(&apos;start&apos;) # 是否以start开头 str1.endswith(&apos;end&apos;) # 是否以end结尾 str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper() # 判断字符串是否全为字符、数字、小写、大写 三重引号编写多行字符串块，并且在代码折行处嵌入换行字符\nmantra = &quot;&quot;&quot;hello world hello python hello my friend&quot;&quot;&quot; # mantra为&quot;&quot;&quot;hello world \n hello python \n hello my friend&quot;&quot;&quot; 索引和分片：S[0], S[len(S)–1], S[-1] # 索引 S[1:3], S[1:], S[:-1], S[1:10:2] # 分片，第三个参数指定步长，如`S[1:10:2]`是从1位到10位没隔2位获取一个字符。 字符串转换工具：int(&apos;42&apos;), str(42) # 返回(42, &apos;42&apos;) float(&apos;4.13&apos;), str(4.13) # 返回(4.13, &apos;4.13&apos;) ord(&apos;s&apos;), chr(115) # 返回(115, &apos;s&apos;) int(&apos;1001&apos;, 2) # 将字符串作为二进制数字，转化为数字，返回9 bin(13), oct(13), hex(13) # 将整数转化为二进制/八进制/十六进制字符串，返回(&apos;0b1101&apos;, &apos;015&apos;, &apos;0xd&apos;) 另类字符串连接name = &quot;wang&quot; &quot;hong&quot; # 单行，name = &quot;wanghong&quot; name = &quot;wang&quot; \ &quot;hong&quot; # 多行，name = &quot;wanghong&quot; Python中的字符串格式化实现1–字符串格式化表达式基于C语言的&apos;print&apos;模型，并且在大多数的现有的语言中使用。 通用结构：%[(name)][flag][width].[precision]typecode &quot;&quot;&quot; &quot;this is %d %s bird&quot; % (1, &apos;dead&apos;) # 一般的格式化表达式 &quot;%s---%s---%s&quot; % (42, 3.14, [1, 2, 3]) # 字符串输出：&apos;42---3.14---[1, 2, 3]&apos; &quot;%d...%6d...%-6d...%06d&quot; % (1234, 1234, 1234, 1234) # 对齐方式及填充：&quot;1234... 1234...1234 ...001234&quot; x = 1.23456789 &quot;%e | %f | %g&quot; % (x, x, x) # 对齐方式：&quot;1.234568e+00 | 1.234568 | 1.23457&quot; &quot;%6.2f*%-6.2f*%06.2f*%+6.2f&quot; % (x, x, x, x) # 对齐方式：&apos; 1.23*1.23 *001.23* +1.23&apos; &quot;%(name1)d---%(name2)s&quot; % {&quot;name1&quot;:23, &quot;name2&quot;:&quot;value2&quot;} # 基于字典的格式化表达式 &quot;%(name)s is %(age)d&quot; % vars() # vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量 Python中的字符串格式化实现2–字符串格式化调用方法# 普通调用 &quot;{0}, {1} and {2}&quot;.format(&apos;spam&apos;, &apos;ham&apos;, &apos;eggs&apos;) # 基于位置的调用 &quot;{motto} and {pork}&quot;.format(motto = &apos;spam&apos;, pork = &apos;ham&apos;) # 基于Key的调用 &quot;{motto} and {0}&quot;.format(&apos;ham&apos;, motto = &apos;spam&apos;) # 混合调用 # 添加键 属性 偏移量 (import sys) &quot;my {1[spam]} runs {0.platform}&quot;.format(sys, {&apos;spam&apos;:&apos;laptop&apos;}) # 基于位置的键和属性 &quot;{config[spam]} {sys.platform}&quot;.format(sys = sys, config = {&apos;spam&apos;:&apos;laptop&apos;}) # 基于Key的键和属性 &quot;first = {0[0]}, second = {0[1]}&quot;.format([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) # 基于位置的偏移量 # 具体格式化 &quot;{0:e}, {1:.3e}, {2:g}&quot;.format(3.14159, 3.14159, 3.14159) # 输出&apos;3.141590e+00, 3.142e+00, 3.14159&apos; &quot;{fieldname:format_spec}&quot;.format(......) # 说明: &quot;&quot;&quot; fieldname是指定参数的一个数字或关键字, 后边可跟可选的&quot;.name&quot;或&quot;[index]&quot;成分引用 format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type] fill ::= &lt;any character&gt; #填充字符 align ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot; #对齐方式 sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot; #符号说明 width ::= integer #字符串宽度 precision ::= integer #浮点数精度 type ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot; &quot;&quot;&quot; # 例子: &apos;={0:10} = {1:10}&apos;.format(&apos;spam&apos;, 123.456) # 输出&apos;=spam = 123.456&apos; &apos;={0:&gt;10}=&apos;.format(&apos;test&apos;) # 输出&apos;= test=&apos; &apos;={0:&lt;10}=&apos;.format(&apos;test&apos;) # 输出&apos;=test =&apos; &apos;={0:^10}=&apos;.format(&apos;test&apos;) # 输出&apos;= test =&apos; &apos;{0:X}, {1:o}, {2:b}&apos;.format(255, 255, 255) # 输出&apos;FF, 377, 11111111&apos; &apos;My name is {0:{1}}.&apos;.format(&apos;Fred&apos;, 8) # 输出&apos;My name is Fred .&apos; 动态指定参数 常用列表常量和操作L = [[1, 2], &apos;string&apos;, {}] # 嵌套列表 L = list(&apos;spam&apos;) # 列表初始化 L = list(range(0, 4)) # 列表初始化 list(map(ord, &apos;spam&apos;)) # 列表解析 len(L) # 求列表长度 L.count(value) # 求列表中某个值的个数 L.append(obj) # 向列表的尾部添加数据，比如append(2)，添加元素2 L.insert(index, obj) # 向列表的指定index位置添加数据，index及其之后的数据后移 L.extend(interable) # 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别 L.index(value, [start, [stop]]) # 返回列表中值value的第一个索引 L.pop([index]) # 删除并返回index处的元素，默认为删除并返回最后一个元素 L.remove(value) # 删除列表中的value值，只删除第一次出现的value的值 L.reverse() # 反转列表 L.sort(cmp=None, key=None, reverse=False) # 排序列表 a = [1, 2, 3], b = a[10:] # 注意，这里不会引发IndexError异常，只会返回一个空的列表[] a = [], a += [1] # 这里实在原有列表的基础上进行操作，即列表的id没有改变 a = [], a = a + [1] # 这里最后的a要构建一个新的列表，即a的id发生了变化 用切片来删除序列的某一段a = [1, 2, 3, 4, 5, 6, 7] a[1:4] = [] # a = [1, 5, 6, 7] a = [0, 1, 2, 3, 4, 5, 6, 7] del a[::2] # 去除偶数项(偶数索引的)，a = [1, 3, 5, 7] 常用字典常量和操作D = {} D = {&apos;spam&apos;:2, &apos;tol&apos;:{&apos;ham&apos;:1}} # 嵌套字典 D = dict.fromkeys([&apos;s&apos;, &apos;d&apos;], 8) # {&apos;s&apos;: 8, &apos;d&apos;: 8} D = dict(name = &apos;tom&apos;, age = 12) # {&apos;age&apos;: 12, &apos;name&apos;: &apos;tom&apos;} D = dict([(&apos;name&apos;, &apos;tom&apos;), (&apos;age&apos;, 12)]) # {&apos;age&apos;: 12, &apos;name&apos;: &apos;tom&apos;} D = dict(zip([&apos;name&apos;, &apos;age&apos;], [&apos;tom&apos;, 12])) # {&apos;age&apos;: 12, &apos;name&apos;: &apos;tom&apos;} D.keys(); D.values(); D.items() # 字典键、值以及键值对 D.get(key, default) # get函数 D.update(D_other) # 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据 D.pop(key, [D]) # 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常 D.popitem() # pop字典中随机的一项（一个键值对） D.setdefault(k[, d]) # 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。 del D # 删除字典 del D[&apos;key&apos;] # 删除字典的某一项 if key in D: if key not in D: # 测试字典键是否存在 # 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象 # 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。 # 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象 D[(1,2,3)] = 2 prices={&apos;book&apos;:38,&apos;pen&apos;:2} min_price = min(zip(prices.values(), prices.keys())) max_price = max(zip(prices.values(), prices.keys())) a,b={&apos;x&apos;:3,&apos;y&apos;:4},{&apos;x&apos;:3,&apos;z&apos;:5} a.keys() &amp; b.keys() a.keys() - b.keys() a.items() &amp; b.items() # tuple作为字典的key calculator={&apos;plus&apos;:lambda x,y : x + y,&apos;minus&apos; : lambda x,y : x - y} res = calculator[&apos;plus&apos;](2, 3) from collections import Counter a = {&apos;a&apos;:1,&apos;b&apos;:2} b = {&apos;a&apos;:1} c = Counter(a) + Counter(b) # 此时c为Counter对象 c = dict(c) # 转变成字典 字典解析D = {k:8 for k in [&apos;s&apos;, &apos;d&apos;]} # {&apos;s&apos;: 8, &apos;d&apos;: 8} D = {k:v for (k, v) in zip([&apos;name&apos;, &apos;age&apos;], [&apos;tom&apos;, 12])} # {&apos;age&apos;: 12, &apos;name&apos;: tom} user_list = [{&apos;name&apos;: &apos;lucy&apos;, &apos;email&apos;: &apos;lucy@g.com&apos;}, {&apos;name&apos;: &apos;lily&apos;, &apos;email&apos;: &apos;lily@g.com&apos;}] user_dict={user[&apos;name&apos;]: user[&apos;email&apos;] for user in user_list if &apos;email&apos; in user} 字典的特殊方法missing：当查找找不到key时，会执行该方法class Dict(dict): def __missing__(self, key): self[key] = [] return self[key] dct = Dict() dct[&quot;foo&quot;].append(1) # 这有点类似于collections.defalutdict dct[&quot;foo&quot;] # [1] 元组和列表的唯一区别在于元组是不可变对象，列表时可变对象a = [1, 2, 3] # a[1] = 0, OK a = (1, 2, 3) # a[1] = 0, Error a = ([1, 2]) # a[0][1] = 0, OK a = [(1, 2)] # a[0][1] = 0, Error 元组的特殊语法: 逗号和圆括号D = (12) # 此时D为一个整数 即D = 12 D = (12, ) # 此时D为一个元组 即D = (12, ) 文件基本操作output = open(r&apos;C:\spam&apos;, &apos;w&apos;) # 打开输出文件，用于写 input = open(&apos;data&apos;, &apos;r&apos;) # 打开输入文件，用于读。打开的方式可以为&apos;w&apos;, &apos;r&apos;, &apos;a&apos;, &apos;wb&apos;, &apos;rb&apos;, &apos;ab&apos;等 fp.read([size]) # size为读取的长度，以byte为单位 fp.readline([size]) # 读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) # 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。 fp.readable() # 是否可读 fp.write(str) # 把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) # 把seq的内容全部写到文件中(多行一次性写入) fp.writeable() # 是否可写 fp.close() # 关闭文件。 fp.flush() # 把缓冲区的内容写入硬盘 fp.fileno() # 返回一个长整型的”文件标签“ fp.isatty() # 文件是否是一个终端设备文件（unix系统中的） fp.tell() # 返回文件操作标记的当前位置，以文件的开头为原点 fp.next() # 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) # 将文件打操作标记移到offset的位置。whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。 fp.seekable() # 是否可以seek fp.truncate([size]) # 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。 for line in open(&apos;data&apos;): print(line) # 使用for语句，比较适用于打开比较大的文件 open(&apos;f.txt&apos;, encoding = &apos;latin-1&apos;) # Python3.x Unicode文本文件 open(&apos;f.bin&apos;, &apos;rb&apos;) # Python3.x 二进制bytes文件 # 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等 其他# Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真 # 通常意义下的类型分类：1. 数字、序列、映射。 2. 可变类型和不可变类型 语法和语句赋值语句的形式record = (&apos;ACME&apos;, 50, 123.45, (12, 18, 2012)) name, *_, (*_, year) = record spam = &apos;spam&apos; # 基本形式 spam, ham = &apos;spam&apos;, &apos;ham&apos; # 元组赋值形式 [spam, ham] = [&apos;s&apos;, &apos;h&apos;] # 列表赋值形式 a, b, c, d = &apos;abcd&apos; # 序列赋值形式 a, *b, c = &apos;spam&apos; # 序列解包形式（Python3.x中才有） spam = ham = &apos;no&apos; # 多目标赋值运算，涉及到共享引用 spam += 42 # 增强赋值，涉及到共享引用 序列赋值 序列解包[a, b, c] = (1, 2, 3) # a = 1, b = 2, c = 3 a, b, c, d = &quot;spam&quot; # a = &apos;s&apos;, b = &apos;p&apos;, c = &apos;a&apos;, d = &apos;m&apos; a, b, c = range(3) # a = 0, b = 1, c = 2 a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4] *a, b = [1, 2, 3, 4] # a = [1, 2, 3], b = 4 a, *b, c = [1, 2, 3, 4] # a = 1, b = [2, 3], c = 4 # 带有*时 会优先匹配*之外的变量 如 a, *b, c = [1, 2] # a = 1, c = 2, b = [] print函数原型print(value, ..., sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False) # 流的重定向 print(&apos;hello world&apos;) # 等于sys.stdout.write(&apos;hello world&apos;) temp = sys.stdout # 原有流的保存 sys.stdout = open(&apos;log.log&apos;, &apos;a&apos;) # 流的重定向 print(&apos;hello world&apos;) # 写入到文件log.log sys.stdout.close() sys.stdout = temp # 原有流的复原 Python中and或or总是返回对象(左边的对象或右边的对象) 且具有短路求值的特性1 or 2 or 3 # 返回 1 1 and 2 and 3 # 返回 3 if/else三元表达符（if语句在行内）A = 1 if X else 2 A = 1 if X else (2 if Y else 3) # 也可以使用and-or语句（一条语句实现多个if-else） result = (a &gt; 20 and &quot;big than 20&quot; or a &gt; 10 and &quot;big than 10&quot; or a &gt; 5 and &quot;big than 5&quot;) Python的while语句或者for语句可以带else语句 当然也可以带continue/break/pass语句while a &gt; 1: anything else: anything # else语句会在循环结束后执行，除非在循环中执行了break，同样的还有for语句 for i in range(5): anything else: anything for循环的元组赋值for (a, b) in [(1, 2), (3, 4)]: # 最简单的赋值 for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: # 自动解包赋值 for ((a, b), c) in [((1, 2), 3), (&quot;XY&quot;, 6)]: # 自动解包 a = X, b = Y, c = 6 for (a, *b) in [(1, 2, 3), (4, 5, 6)]: # 自动解包赋值 列表解析语法M = [[1,2,3], [4,5,6], [7,8,9]] res = [sum(row) for row in M] # G = [6, 15, 24] 一般的列表解析 生成一个列表 res = [c * 2 for c in &apos;spam&apos;] # [&apos;ss&apos;, &apos;pp&apos;, &apos;aa&apos;, &apos;mm&apos;] res = [a * b for a in [1, 2] for b in [4, 5]] # 多解析过程 返回[4, 5, 8, 10] res = [a for a in [1, 2, 3] if a &lt; 2] # 带判断条件的解析过程 res = [a if a &gt; 0 else 0 for a in [-1, 0, 1]] # 带判断条件的高级解析过程 # 两个列表同时解析：使用zip函数 for teama, teamb in zip([&quot;Packers&quot;, &quot;49ers&quot;], [&quot;Ravens&quot;, &quot;Patriots&quot;]): print(teama + &quot; vs. &quot; + teamb) # 带索引的列表解析：使用enumerate函数 for index, team in enumerate([&quot;Packers&quot;, &quot;49ers&quot;, &quot;Ravens&quot;, &quot;Patriots&quot;]): print(index, team) # 输出0, Packers \n 1, 49ers \n ...... matrix = [[1, 2, 3],[4, 5, 6]] res = zip( *matrix ) sum(a, []) # 展平 a = [1, 2, [3, 4], [[5, 6], [7, 8]]] flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x] flatten(a) multipliers = [(lambda x, i=i: x * i) for i in range(0, 20)] 生成器表达式G = (sum(row) for row in M) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 输出(6, 15, 24) G = {sum(row) for row in M} # G = {6, 15, 24} 解析语法还可以生成集合和字典 G = {i:sum(M[i]) for i in range(3)} # G = {0: 6, 1: 15, 2: 24} 文档字符串:出现在Module的开端以及其中函数或类的开端 使用三重引号字符串&quot;&quot;&quot; module document &quot;&quot;&quot; def func(): &quot;&quot;&quot; function document &quot;&quot;&quot; print() class Employee: &quot;&quot;&quot; class document &quot;&quot;&quot; print() print(func.__doc__) # 输出函数文档字符串 print(Employee.__doc__) # 输出类的文档字符串 命名惯例:&quot;&quot;&quot; 以单一下划线开头的变量名(_X)不会被from module import*等语句导入 前后有两个下划线的变量名(__X__)是系统定义的变量名，对解释器有特殊意义 以两个下划线开头但不以下划线结尾的变量名(__X)是类的本地(私有)变量 &quot;&quot;&quot; 列表解析 in成员关系测试 map sorted zip enumerate内置函数等都使用了迭代协议&apos;first line&apos; in open(&apos;test.txt&apos;) # in测试 返回True或False list(map(str.upper, open(&apos;t&apos;))) # map内置函数 sorted(iter([2, 5, 8, 3, 1])) # sorted内置函数 list(zip([1, 2], [3, 4])) # zip内置函数 [(1, 3), (2, 4)] del语句: 手动删除某个变量del X 获取列表的子表的方法:x = [1,2,3,4,5,6] x[:3] # 前3个[1,2,3] x[1:5] # 中间4个[2,3,4,5] x[-3:] # 最后3个[4,5,6] x[::2] # 奇数项[1,3,5] x[1::2] # 偶数项[2,4,6] 手动迭代：iter和nextL = [1, 2] I = iter(L) # I为L的迭代器 I.next() # 返回1 I.next() # 返回2 I.next() # Error:StopIteration Python中的可迭代对象&quot;&quot;&quot; 1.range迭代器 2.map、zip和filter迭代器 3.字典视图迭代器：D.keys()), D.items()等 4.文件类型 &quot;&quot;&quot; 函数语法规则函数相关的语句和表达式myfunc(&apos;spam&apos;) # 函数调用 def myfunc(): # 函数定义 return None # 函数返回值 global a # 全局变量 nonlocal x # 在函数或其他作用域中使用外层（非全局）变量 yield x # 生成器函数返回 lambda # 匿名函数 Python函数变量名解析:LEGB原则，即:&quot;&quot;&quot; local(functin) --&gt; encloseing function locals --&gt; global(module) --&gt; build-in(python) 说明:以下边的函数maker为例 则相对于action而言 X为Local N为Encloseing &quot;&quot;&quot; 嵌套函数举例:工厂函数def maker(N): def action(X): return X ** N return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X 嵌套函数举例:lambda实例def maker(N): action = (lambda X: X**N) return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X nonlocal和global语句的区别# nonlocal应用于一个嵌套的函数的作用域中的一个名称 例如: start = 100 def tester(start): def nested(label): nonlocal start # 指定start为tester函数内的local变量 而不是global变量start print(label, start) start += 3 return nested # global为全局的变量 即def之外的变量 def tester(start): def nested(label): global start # 指定start为global变量start print(label, start) start += 3 return nested 函数参数，不可变参数通过“值”传递，可变参数通过“引用”传递def f(a, b, c): print(a, b, c) f(1, 2, 3) # 参数位置匹配 f(1, c = 3, b = 2) # 参数关键字匹配 def f(a, b=1, c=2): print(a, b, c) f(1) # 默认参数匹配 f(1, 2) # 默认参数匹配 f(a = 1, c = 3) # 关键字参数和默认参数的混合 # Keyword-Only参数:出现在*args之后 必须用关键字进行匹配 def keyOnly(a, *b, c): print(&apos;&apos;) # c就为keyword-only匹配 必须使用关键字c = value匹配 def keyOnly(a, *, b, c): ...... # b c为keyword-only匹配 必须使用关键字匹配 def keyOnly(a, *, b = 1): ...... # b有默认值 或者省略 或者使用关键字参数b = value 可变参数匹配: 和 *def f(*args): print(args) # 在元组中收集不匹配的位置参数 f(1, 2, 3) # 输出(1, 2, 3) def f(**args): print(args) # 在字典中收集不匹配的关键字参数 f(a = 1, b = 2) # 输出{&apos;a&apos;:1, &apos;b&apos;:2} def f(a, *b, **c): print(a, b, c) # 两者混合使用 f(1, 2, 3, x=4, y=5) # 输出1, (2, 3), {&apos;x&apos;:4, &apos;y&apos;:5} 函数调用时的参数解包: 和 * 分别解包元组和字典func(1, *(2, 3)) &lt;==&gt; func(1, 2, 3) func(1, **{&apos;c&apos;:3, &apos;b&apos;:2}) &lt;==&gt; func(1, b = 2, c = 3) func(1, *(2, 3), **{&apos;c&apos;:3, &apos;b&apos;:2}) &lt;==&gt; func(1, 2, 3, b = 2, c = 3) 函数属性:(自己定义的)函数可以添加属性def func():..... func.count = 1 # 自定义函数添加属性 print.count = 1 # Error 内置函数不可以添加属性 函数注解: 编写在def头部行 主要用于说明参数范围、参数类型、返回值类型等def func(a:&apos;spam&apos;, b:(1, 10), c:float) -&gt; int : print(a, b, c) func.__annotations__ # {&apos;c&apos;:&lt;class &apos;float&apos;&gt;, &apos;b&apos;:(1, 10), &apos;a&apos;:&apos;spam&apos;, &apos;return&apos;:&lt;class &apos;int&apos;&gt;} # 编写注解的同时 还是可以使用函数默认值 并且注解的位置位于=号的前边 def func(a:&apos;spam&apos;=&apos;a&apos;, b:(1, 10)=2, c:float=3) -&gt; int : print(a, b, c) 匿名函数:lambdaf = lambda x, y, z : x + y + z # 普通匿名函数，使用方法f(1, 2, 3) f = lambda x = 1, y = 1: x + y # 带默认参数的lambda函数 def action(x): # 嵌套lambda函数 return (lambda y : x + y) f = lambda: a if xxx() else b # 无参数的lambda函数，使用方法f() lambda函数与map filter reduce函数的结合list(map((lambda x: x + 1), [1, 2, 3])) # [2, 3, 4] list(filter((lambda x: x &gt; 0), range(-4, 5))) # [1, 2, 3, 4] functools.reduce((lambda x, y: x + y), [1, 2, 3]) # 6 functools.reduce((lambda x, y: x * y), [2, 3, 4]) # 24 生成器函数:yield VS returndef gensquare(N): for i in range(N): yield i** 2 # 状态挂起 可以恢复到此时的状态 for i in gensquare(5): # 使用方法 print(i, end = &apos; &apos;) # [0, 1, 4, 9, 16] x = gensquare(2) # x是一个生成对象 next(x) # 等同于x.__next__() 返回0 next(x) # 等同于x.__next__() 返回1 next(x) # 等同于x.__next__() 抛出异常StopIteration 生成器表达式:小括号进行列表解析G = (x ** 2 for x in range(3)) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 和上述中的生成器函数的返回值一致 #（1）生成器(生成器函数/生成器表达式)是单个迭代对象 G = (x ** 2 for x in range(4)) I1 = iter(G) # 这里实际上iter(G) = G next(I1) # 输出0 next(G) # 输出1 next(I1) # 输出4 #（2）生成器不保留迭代后的结果 gen = (i for i in range(4)) 2 in gen # 返回True 3 in gen # 返回True 1 in gen # 返回False，其实检测2的时候，1已经就不在生成器中了，即1已经被迭代过了，同理2、3也不在了 本地变量是静态检测的X = 22 # 全局变量X的声明和定义 def test(): print(X) # 如果没有下一语句 则该句合法 打印全局变量X X = 88 # 这一语句使得上一语句非法 因为它使得X变成了本地变量 上一句变成了打印一个未定义的本地变量(局部变量) if False: # 即使这样的语句 也会把print语句视为非法语句 因为: X = 88 # Python会无视if语句而仍然声明了局部变量X def test(): # 改进 global X # 声明变量X为全局变量 print(X) # 打印全局变量X X = 88 # 改变全局变量X 函数的默认值是在函数定义的时候实例化的 而不是在调用的时候 例子:def foo(numbers=[]): # 这里的[]是可变的 numbers.append(9) print(numbers) foo() # first time, like before, [9] foo() # second time, not like before, [9, 9] foo() # third time, not like before too, [9, 9, 9] # 改进: def foo(numbers=None): if numbers is None: numbers = [] numbers.append(9) print(numbers) # 另外一个例子 参数的默认值为不可变的: def foo(count=0): # 这里的0是数字, 是不可变的 count += 1 print(count) foo() # 输出1 foo() # 还是输出1 foo(3) # 输出4 foo() # 还是输出1 函数例子&quot;&quot;&quot;数学运算类&quot;&quot;&quot; abs(x) # 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模 complex([real[, imag]]) # 创建一个复数 divmod(a, b) # 分别取商和余数，注意：整型、浮点型都可以 float([x]) # 将一个字符串或数转换为浮点数。如果无参数将返回0.0 int([x[, base]]) # 将一个字符串或浮点数转换为int类型，base表示进制 long([x[, base]]) # 将一个字符串或浮点数转换为long类型 pow(x, y) # 返回x的y次幂 range([start], stop[, step]) # 产生一个序列，默认从0开始 round(x[, n]) # 四舍五入 sum(iterable[, start]) # 对集合求和 oct(x) # 将一个数字转化为8进制字符串 hex(x) # 将一个数字转换为16进制字符串 chr(i) # 返回给定int类型对应的ASCII字符 unichr(i) # 返回给定int类型的unicode ord(c) # 返回ASCII字符对应的整数 bin(x) # 将整数x转换为二进制字符串 bool([x]) # 将x转换为Boolean类型 &quot;&quot;&quot;集合类操作&quot;&quot;&quot; basestring() # str和unicode的超类，不能直接调用，可以用作isinstance判断 format(value [, format_spec]) # 格式化输出字符串，格式化的参数顺序从0开始，如“I am {0},I like {1}” enumerate(sequence[, start=0]) # 返回一个可枚举的对象，注意它有第二个参数 iter(obj[, sentinel]) # 生成一个对象的迭代器，第二个参数表示分隔符 max(iterable[, args...][key]) # 返回集合中的最大值 min(iterable[, args...][key]) # 返回集合中的最小值 dict([arg]) # 创建数据字典 list([iterable]) # 将一个集合类转换为另外一个集合类 set() # set对象实例化 frozenset([iterable]) # 产生一个不可变的set tuple([iterable]) # 生成一个tuple类型 str([object]) # 转换为string类型 sorted(iterable[, cmp[, key[, reverse]]]) # 集合排序 L = [(&apos;b&apos;,2),(&apos;a&apos;,1),(&apos;c&apos;,3),(&apos;d&apos;,4)] sorted(L, key=lambda x: x[1]), reverse=True) # 使用Key参数和reverse参数 sorted(L, key=lambda x: (x[0], x[1])) # 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1] &quot;&quot;&quot;逻辑判断&quot;&quot;&quot; all(iterable) # 集合中的元素都为真的时候为真，特别的，若为空串返回为True any(iterable) # 集合中的元素有一个为真的时候为真，特别的，若为空串返回为False cmp(x, y) # 如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数 &quot;&quot;&quot;IO操作&quot;&quot;&quot; file(filename [, mode [, bufsize]]) # file类型的构造函数。 input([prompt]) # 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入 raw_input([prompt]) # 设置输入，输入都是作为字符串处理 open(name[, mode[, buffering]]) # 打开文件，与file有什么不同？推荐使用open &quot;&quot;&quot;其他&quot;&quot;&quot; callable(object) # 检查对象object是否可调用 classmethod(func) # 用来说明这个func是个类方法 staticmethod(func) # 用来说明这个func为静态方法 dir([object]) # 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 help(obj) # 返回obj的帮助信息 eval(expression) # 计算表达式expression的值，并返回 exec(str) # 将str作为Python语句执行 execfile(filename) # 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。 filter(function, iterable) # 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数 list(filter(bool, range(-3, 4)))# 返回[-3, -2, -1, 1, 2, 3], 没有0 hasattr(object, name) # 判断对象object是否包含名为name的特性 getattr(object, name [, defalut]) # 获取一个类的属性 setattr(object, name, value) # 设置属性值 delattr(object, name) # 删除object对象名为name的属性 globals() # 返回一个描述当前全局符号表的字典 hash(object) # 如果对象object为哈希表类型，返回对象object的哈希值 id(object) # 返回对象的唯一标识，一串数字 isinstance(object, classinfo) # 判断object是否是class的实例 isinstance(1, int) # 判断是不是int类型 isinstance(1, (int, float)) # isinstance的第二个参数接受一个元组类型 issubclass(class, classinfo) # 判断class是否为classinfo的子类 locals() # 返回当前的变量列表 map(function, iterable, ...) # 遍历每个元素，执行function操作 list(map(abs, range(-3, 4))) # 返回[3, 2, 1, 0, 1, 2, 3] next(iterator[, default]) # 类似于iterator.next() property([fget[, fset[, fdel[, doc]]]]) # 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter reduce(function, iterable[, initializer]) # 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推 def add(x,y):return x + y reduce(add, range(1, 11)) # 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55) reduce(add, range(1, 11), 20) # 返回75 reload(module) # 重新加载模块 repr(object) # 将一个对象变幻为可打印的格式 slice(start, stop[, step]) # 产生分片对象 type(object) # 返回该object的类型 vars([object]) # 返回对象的变量名、变量值得字典 a = Class(); # Class为一个空类 a.name = &apos;qi&apos;, a.age = 9 vars(a) # {&apos;name&apos;:&apos;qi&apos;, &apos;age&apos;:9} zip([iterable, ...]) # 返回对应数组 list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)] a = [1, 2, 3], b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] z = zip(a, b) # 压缩：[(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;)] zip(*z) # 解压缩：[(1, 2, 3), (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)] unicode(string, encoding, errors) # 将字符串string转化为unicode形式，string为encoded string。 模块MoudlePython模块搜索路径:&quot;&quot;&quot; (1)程序的主目录 (2)PYTHONPATH目录 (3)标准链接库目录 (4)任何.pth文件的内容 &quot;&quot;&quot; 查看全部的模块搜索路径import sys sys.path sys.argv # 获得脚本的参数 sys.builtin_module_names # 查找内建模块 sys.platform # 返回当前平台 出现如： &quot;win32&quot; &quot;linux&quot; &quot;darwin&quot;等 sys.modules # 查找已导入的模块 sys.modules.keys() sys.stdout # stdout 和 stderr 都是类文件对象，但是它们都是只写的。它们都没有 read 方法，只有 write 方法 sys.stdout.write(&quot;hello&quot;) sys.stderr sys.stdin 模块的使用代码import module1, module2 # 导入module1 使用module1.printer() from module1 import printer # 导入module1中的printer变量 使用printer() from module1 import * # 导入module1中的全部变量 使用不必添加module1前缀 重载模块reload: 这是一个内置函数 而不是一条语句from imp import reload reload(module) 模块的包导入:使用点号(.)而不是路径(dir1\dir2)进行导入import dir1.dir2.mod # d导入包(目录)dir1中的包dir2中的mod模块 此时dir1必须在Python可搜索路径中 from dir1.dir2.mod import * # from语法的包导入 init.py包文件:每个导入的包中都应该包含这么一个文件&quot;&quot;&quot; 该文件可以为空 首次进行包导入时 该文件会自动执行 高级功能:在该文件中使用__all__列表来定义包(目录)以from*的形式导入时 需要导入什么 &quot;&quot;&quot; 包相对导入:使用点号(.) 只能使用from语句from . import spam # 导入当前目录下的spam模块（错误: 当前目录下的模块, 直接导入即可） from .spam import name # 导入当前目录下的spam模块的name属性（错误: 当前目录下的模块, 直接导入即可，不用加.） from .. import spam # 导入当前目录的父目录下的spam模块 包相对导入与普通导入的区别from string import * # 这里导入的string模块为sys.path路径上的 而不是本目录下的string模块(如果存在也不是) from .string import * # 这里导入的string模块为本目录下的(不存在则导入失败) 而不是sys.path路径上的 模块数据隐藏:最小化from*的破坏_X # 变量名前加下划线可以防止from*导入时该变量名被复制出去 __all__ = [&apos;x&apos;, &apos;x1&apos;, &apos;x2&apos;] # 使用__all__列表指定from*时复制出去的变量名(变量名在列表中为字符串形式) 可以使用name进行模块的单元测试:当模块为顶层执行文件时值为’main‘ 当模块被导入时为模块名if __name__ == &apos;__main__&apos;: doSomething # 模块属性中还有其他属性，例如： __doc__ # 模块的说明文档 __file__ # 模块文件的文件名，包括全路径 __name__ # 主文件或者被导入文件 __package__ # 模块所在的包 import语句from语句的as扩展import modulename as name from modulename import attrname as name 得到模块属性的几种方法 假设为了得到name属性的值M.name M.__dict__[&apos;name&apos;] sys.modules[&apos;M&apos;].name getattr(M, &apos;name&apos;) 类与面向对象最普通的类class C1(C2, C3): spam = 42 # 数据属性 def __init__(self, name): # 函数属性:构造函数 self.name = name def __del__(self): # 函数属性:析构函数 print(&quot;goodbey &quot;, self.name) I1 = C1(&apos;bob&apos;) Python的类没有基于参数的函数重载class FirstClass: def test(self, string): print(string) def test(self): # 此时类中只有一个test函数 即后者test(self) 它覆盖掉前者带参数的test函数 print(&quot;hello world&quot;) 子类扩展超类: 尽量调用超类的方法class Manager(Person): def giveRaise(self, percent, bonus = .10): self.pay = int(self.pay*(1 + percent + bonus)) # 不好的方式 复制粘贴超类代码 Person.giveRaise(self, percent + bonus) # 好的方式 尽量调用超类方法 类内省工具bob = Person(&apos;bob&apos;) bob.__class__ # &lt;class &apos;Person&apos;&gt; bob.__class__.__name__ # &apos;Person&apos; bob.__dict__ # {&apos;pay&apos;:0, &apos;name&apos;:&apos;bob&apos;, &apos;job&apos;:&apos;Manager&apos;} 返回1中 数据属性spam是属于类 而不是对象I1 = C1(&apos;bob&apos;); I2 = C2(&apos;tom&apos;) # 此时I1和I2的spam都为42 但是都是返回的C1的spam属性 C1.spam = 24 # 此时I1和I2的spam都为24 I1.spam = 3 # 此时I1新增自有属性spam 值为2 I2和C1的spam还都为24 类方法调用的两种方式instance.method(arg...) class.method(instance, arg...) 抽象超类的实现方法# (1)某个函数中调用未定义的函数 子类中定义该函数 def delegate(self): self.action() # 本类中不定义action函数 所以使用delegate函数时就会出错 # (2)定义action函数 但是返回异常 def action(self): raise NotImplementedError(&quot;action must be defined&quot;) # (3)上述的两种方法还都可以定义实例对象 实际上可以利用@装饰器语法生成不能定义的抽象超类 from abc import ABCMeta, abstractmethod class Super(metaclass = ABCMeta): @abstractmethod def action(self): pass x = Super() # 返回 TypeError: Can&apos;t instantiate abstract class Super with abstract methods action # OOP和继承: “is-a”的关系class A(B): pass a = A() isinstance(a, B) # 返回True, A是B的子类 a也是B的一种 # OOP和组合: &quot;has-a&quot;的关系 pass # OOP和委托: &quot;包装&quot;对象 在Python中委托通常是以&quot;__getattr__&quot;钩子方法实现的, 这个方法会拦截对不存在属性的读取 # 包装类(或者称为代理类)可以使用__getattr__把任意读取转发给被包装的对象 class wrapper: def __init__(self, object): self.wrapped = object def __getattr(self, attrname): print(&apos;Trace: &apos;, attrname) return getattr(self.wrapped, attrname) # 注:这里使用getattr(X, N)内置函数以变量名字符串N从包装对象X中取出属性 类似于X.__dict__[N] x = wrapper([1, 2, 3]) x.append(4) # 返回 &quot;Trace: append&quot; [1, 2, 3, 4] x = wrapper({&apos;a&apos;:1, &apos;b&apos;:2}) list(x.keys()) # 返回 &quot;Trace: keys&quot; [&apos;a&apos;, &apos;b&apos;] 类的伪私有属性:使用__attrclass C1: def __init__(self, name): self.__name = name # 此时类的__name属性为伪私有属性 原理 它会自动变成self._C1__name = name def __str__(self): return &apos;self.name = %s&apos; % self.__name I = C1(&apos;tom&apos;) print(I) # 返回 self.name = tom I.__name = &apos;jeey&apos; # 这里无法访问 __name为伪私有属性 I._C1__name = &apos;jeey&apos; # 这里可以修改成功 self.name = jeey 类方法是对象:无绑定类方法对象 / 绑定实例方法对象class Spam: def doit(self, message): print(message) def selfless(message) print(message) obj = Spam() x = obj.doit # 类的绑定方法对象 实例 + 函数 x(&apos;hello world&apos;) x = Spam.doit # 类的无绑定方法对象 类名 + 函数 x(obj, &apos;hello world&apos;) x = Spam.selfless # 类的无绑定方法是函数 在3.0之前无效 x(&apos;hello world&apos;) 获取对象信息: 属性和方法a = MyObject() dir(a) # 使用dir函数 hasattr(a, &apos;x&apos;) # 测试是否有x属性或方法 即a.x是否已经存在 setattr(a, &apos;y&apos;, 19) # 设置属性或方法 等同于a.y = 19 getattr(a, &apos;z&apos;, 0) # 获取属性或方法 如果属性不存在 则返回默认值0 #这里有个小技巧，setattr可以设置一个不能访问到的属性，即只能用getattr获取 setattr(a, &quot;can&apos;t touch&quot;, 100) # 这里的属性名带有空格，不能直接访问 getattr(a, &quot;can&apos;t touch&quot;, 0) # 但是可以用getattr获取 为类动态绑定属性或方法: MethodType方法# 一般创建了一个class的实例后, 可以给该实例绑定任何属性和方法, 这就是动态语言的灵活性 class Student(object): pass s = Student() s.name = &apos;Michael&apos; # 动态给实例绑定一个属性 def set_age(self, age): # 定义一个函数作为实例方法 self.age = age from types import MethodType s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 类的其他实例不受此影响 s.set_age(25) # 调用实例方法 Student.set_age = MethodType(set_age, Student) # 为类绑定一个方法 类的所有实例都拥有该方法 类的高级话题多重继承: “混合类”, 搜索方式”从下到上 从左到右 广度优先”class A(B, C): pass 类的继承和子类的初始化# 1.子类定义了__init__方法时，若未显示调用基类__init__方法，python不会帮你调用。 # 2.子类未定义__init__方法时，python会自动帮你调用首个基类的__init__方法，注意是首个。 # 3.子类显示调用基类的初始化函数： class FooParent(object): def __init__(self, a): self.parent = &apos;I\&apos;m the Parent.&apos; print(&apos;Parent:a=&apos; + str(a)) def bar(self, message): print(message + &apos; from Parent&apos;) class FooChild(FooParent): def __init__(self, a): FooParent.__init__(self, a) print(&apos;Child:a=&apos; + str(a)) def bar(self, message): FooParent.bar(self, message) print(message + &apos; from Child&apos;) fooChild = FooChild(10) fooChild.bar(&apos;HelloWorld&apos;) #实例方法 / 静态方法 / 类方法class Methods: def imeth(self, x): print(self, x) # 实例方法：传入的是实例和数据，操作的是实例的属性 def smeth(x): print(x) # 静态方法：只传入数据 不传入实例，操作的是类的属性而不是实例的属性 def cmeth(cls, x): print(cls, x) # 类方法：传入的是类对象和数据 smeth = staticmethod(smeth) # 调用内置函数，也可以使用@staticmethod cmeth = classmethod(cmeth) # 调用内置函数，也可以使用@classmethod obj = Methods() obj.imeth(1) # 实例方法调用 &lt;__main__.Methods object...&gt; 1 Methods.imeth(obj, 2) # &lt;__main__.Methods object...&gt; 2 Methods.smeth(3) # 静态方法调用 3 obj.smeth(4) # 这里可以使用实例进行调用 Methods.cmeth(5) # 类方法调用 &lt;class &apos;__main__.Methods&apos;&gt; 5 obj.cmeth(6) # &lt;class &apos;__main__.Methods&apos;&gt; 6 函数装饰器:是它后边的函数的运行时的声明 由@符号以及后边紧跟的”元函数”(metafunction)组成 @staticmethod def smeth(x): print(x) # 等同于: def smeth(x): print(x) smeth = staticmethod(smeth) # 同理 @classmethod def cmeth(cls, x): print(x) # 等同于 def cmeth(cls, x): print(x) cmeth = classmethod(cmeth) 类修饰器:是它后边的类的运行时的声明 由@符号以及后边紧跟的”元函数”(metafunction)组成 def decorator(aClass):..... @decorator class C:.... # 等同于: class C:.... C = decorator(C) 限制class属性: slots属性class Student: __slots__ = (&apos;name&apos;, &apos;age&apos;) # 限制Student及其实例只能拥有name和age属性 # __slots__属性只对当前类起作用, 对其子类不起作用 # __slots__属性能够节省内存 # __slots__属性可以为列表list，或者元组tuple 类属性高级话题: @property# 假设定义了一个类:C，该类必须继承自object类，有一私有变量_x class C(object): def __init__(self): self.__x = None # 第一种使用属性的方法 def getx(self): return self.__x def setx(self, value): self.__x = value def delx(self): del self.__x x = property(getx, setx, delx, &apos;&apos;) # property函数原型为property(fget=None,fset=None,fdel=None,doc=None) # 使用 c = C() c.x = 100 # 自动调用setx方法 y = c.x # 自动调用getx方法 del c.x # 自动调用delx方法 # 第二种方法使用属性的方法 @property def x(self): return self.__x @x.setter def x(self, value): self.__x = value @x.deleter def x(self): del self.__x # 使用 c = C() c.x = 100 # 自动调用setter方法 y = c.x # 自动调用x方法 del c.x # 自动调用deleter方法 定制类: 重写类的方法# (1)__str__方法、__repr__方法: 定制类的输出字符串 # (2)__iter__方法、next方法: 定制类的可迭代性 class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def next(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 for n in Fib(): print(n) # 使用 # (3)__getitem__方法、__setitem__方法: 定制类的下标操作[] 或者切片操作slice class Indexer(object): def __init__(self): self.data = {} def __getitem__(self, n): # 定义getitem方法 print(&apos;getitem:&apos;, n) return self.data[n] def __setitem__(self, key, value): # 定义setitem方法 print(&apos;setitem:key = {0}, value = {1}&apos;.format(key, value)) self.data[key] = value test = Indexer() test[0] = 1; test[3] = &apos;3&apos; # 调用setitem方法 print(test[0]) # 调用getitem方法 # (4)__getattr__方法: 定制类的属性操作 class Student(object): def __getattr__(self, attr): # 定义当获取类的属性时的返回值 if attr==&apos;age&apos;: return 25 # 当获取age属性时返回25 raise AttributeError(&apos;object has no attribute: %s&apos; % attr) # 注意: 只有当属性不存在时 才会调用该方法 且该方法默认返回None 需要在函数最后引发异常 s = Student() s.age # s中age属性不存在 故调用__getattr__方法 返回25 # (5)__call__方法: 定制类的&apos;可调用&apos;性 class Student(object): def __call__(self): # 也可以带参数 print(&apos;Calling......&apos;) s = Student() s() # s变成了可调用的 也可以带参数 callable(s) # 测试s的可调用性 返回True # (6)__len__方法：求类的长度 def __len__(self): return len(self.data) 动态创建类type()# 一般创建类 需要在代码中提前定义 class Hello(object): def hello(self, name=&apos;world&apos;): print(&apos;Hello, %s.&apos; % name) h = Hello() h.hello() # Hello, world type(Hello) # Hello是一个type类型 返回&lt;class &apos;type&apos;&gt; type(h) # h是一个Hello类型 返回&lt;class &apos;Hello&apos;&gt; # 动态类型语言中 类可以动态创建 type函数可用于创建新类型 def fn(self, name=&apos;world&apos;): # 先定义函数 print(&apos;Hello, %s.&apos; % name) Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello类 type原型: type(name, bases, dict) h = Hello() # 此时的h和上边的h一致 异常相关#捕获异常: try: except: # 捕获所有的异常 等同于except Exception: except name: # 捕获指定的异常 except name, value: # 捕获指定的异常和额外的数据(实例) except (name1, name2): except (name1, name2), value: except name4 as X: else: # 如果没有发生异常 finally: # 总会执行的部分 # 引发异常: raise子句(raise IndexError) raise &lt;instance&gt; # raise instance of a class, raise IndexError() raise &lt;class&gt; # make and raise instance of a class, raise IndexError raise # reraise the most recent exception Python3.x中的异常链: raise exception from otherExceptionexcept Exception as X: raise IndexError(&apos;Bad&apos;) from X assert子句: assert , assert x &lt; 0, &apos;x must be negative&apos; with/as环境管理器:作为常见的try/finally用法模式的替代方案with expression [as variable], expression [as variable]: # 例子: with open(&apos;test.txt&apos;) as myfile: for line in myfile: print(line) # 等同于: myfile = open(&apos;test.txt&apos;) try: for line in myfile: print(line) finally: myfile.close() 用户自定义异常: class Bad(Exception):…..&quot;&quot;&quot; Exception超类 / except基类即可捕获到其所有子类 Exception超类有默认的打印消息和状态 当然也可以定制打印显示: &quot;&quot;&quot; class MyBad(Exception): def __str__(self): return &apos;定制的打印消息&apos; try: MyBad() except MyBad as x: print(x) 用户定制异常数据class FormatError(Exception): def __init__(self, line ,file): self.line = line self.file = file try: raise FormatError(42, &apos;test.py&apos;) except FormatError as X: print(&apos;Error at &apos;, X.file, X.line) # 用户定制异常行为(方法):以记录日志为例 class FormatError(Exception): logfile = &apos;formaterror.txt&apos; def __init__(self, line ,file): self.line = line self.file = file def logger(self): open(self.logfile, &apos;a&apos;).write(&apos;Error at &apos;, self.file, self.line) try: raise FormatError(42, &apos;test.py&apos;) except FormatError as X: X.logger() 关于sys.exc_info:允许一个异常处理器获取对最近引发的异常的访问try: ...... except: # 此时sys.exc_info()返回一个元组(type, value, traceback) # type:正在处理的异常的异常类型 # value:引发的异常的实例 # traceback:堆栈信息 异常层次BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning Unicode和字节字符串Python的字符串类型&quot;&quot;&quot;Python2.x&quot;&quot;&quot; # 1.str表示8位文本和二进制数据 # 2.unicode表示宽字符Unicode文本 &quot;&quot;&quot;Python3.x&quot;&quot;&quot; # 1.str表示Unicode文本（8位或者更宽） # 2.bytes表示不可变的二进制数据 # 3.bytearray是一种可变的bytes类型 字符编码方法&quot;&quot;&quot;ASCII&quot;&quot;&quot; # 一个字节，只包含英文字符，0到127，共128个字符，利用函数可以进行字符和数字的相互转换 ord(&apos;a&apos;) # 字符a的ASCII码为97，所以这里返回97 chr(97) # 和上边的过程相反，返回字符&apos;a&apos; &quot;&quot;&quot;Latin-1&quot;&quot;&quot; # 一个字节，包含特殊字符，0到255，共256个字符，相当于对ASCII码的扩展 chr(196) # 返回一个特殊字符：Ä &quot;&quot;&quot;Unicode&quot;&quot;&quot; # 宽字符，一个字符包含多个字节，一般用于亚洲的字符集，比如中文有好几万字 &quot;&quot;&quot;UTF-8&quot;&quot;&quot; # 可变字节数，小于128的字符表示为单个字节，128到0X7FF之间的代码转换为两个字节，0X7FF以上的代码转换为3或4个字节 # 注意：可以看出来，ASCII码是Latin-1和UTF-8的一个子集 # 注意：utf-8是unicode的一种实现方式，unicode、gbk、gb2312是编码字符集 查看Python中的字符串编码名称，查看系统的编码import encodings help(encoding) import sys sys.platform # &apos;win64&apos; sys.getdefaultencoding() # &apos;utf-8&apos; sys.getdefaultencoding() # 返回当前系统平台的编码类型 sys.getsizeof(object) # 返回object占有的bytes的大小 源文件字符集编码声明: 添加注释来指定想要的编码形式 从而改变默认值 注释必须出现在脚本的第一行或者第二行&quot;&quot;&quot;说明：其实这里只会检查#和coding:utf-8，其余的字符都是为了美观加上的&quot;&quot;&quot; # _*_ coding: utf-8 _*_ # coding = utf-8 #编码: 字符串 –&gt; 原始字节 #解码: 原始字节 –&gt; 字符串Python3.x中的字符串应用s = &apos;...&apos; # 构建一个str对象，不可变对象 b = b&apos;...&apos; # 构建一个bytes对象，不可变对象 s[0], b[0] # 返回(&apos;.&apos;, 113) s[1:], b[1:] # 返回(&apos;..&apos;, b&apos;..&apos;) B = B&quot;&quot;&quot; xxxx yyyy &quot;&quot;&quot; # B = b&apos;\nxxxx\nyyyy\n&apos; # 编码，将str字符串转化为其raw bytes形式： str.encode(encoding = &apos;utf-8&apos;, errors = &apos;strict&apos;) bytes(str, encoding) # 编码例子： S = &apos;egg&apos; S.encode() # b&apos;egg&apos; bytes(S, encoding = &apos;ascii&apos;) # b&apos;egg&apos; # 解码，将raw bytes字符串转化为str形式： bytes.decode(encoding = &apos;utf-8&apos;, errors = &apos;strict&apos;) str(bytes_or_buffer[, encoding[, errors]]) # 解码例子： B = b&apos;spam&apos; B.decode() # &apos;spam&apos; str(B) # &quot;b&apos;spam&apos;&quot;，不带编码的str调用，结果为打印该bytes对象 str(B, encoding = &apos;ascii&apos;)# &apos;spam&apos;，带编码的str调用，结果为转化该bytes对象 bytes对象B = b&apos;abc&apos; B = bytes(&apos;abc&apos;, &apos;ascii&apos;) B = bytes([97, 98, 99]) B = &apos;abc&apos;.encode() # bytes对象的方法调用基本和str类型一致 但:B[0]返回的是ASCII码值97, 而不是b&apos;a&apos; #文本文件: 根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是指定的编码类型# 二进制文件：表示字节值的整数的一个序列 open(&apos;bin.txt&apos;, &apos;rb&apos;) Unicode文件s = &apos;A\xc4B\xe8C&apos; # s = &apos;A?BèC&apos; len(s) = 5 #手动编码 l = s.encode(&apos;latin-1&apos;) # l = b&apos;A\xc4B\xe8C&apos; len(l) = 5 u = s.encode(&apos;utf-8&apos;) # u = b&apos;A\xc3\x84B\xc3\xa8C&apos; len(u) = 7 #文件输出编码 open(&apos;latindata&apos;, &apos;w&apos;, encoding = &apos;latin-1&apos;).write(s) l = open(&apos;latindata&apos;, &apos;rb&apos;).read() # l = b&apos;A\xc4B\xe8C&apos; len(l) = 5 open(&apos;uft8data&apos;, &apos;w&apos;, encoding = &apos;utf-8&apos;).write(s) u = open(&apos;uft8data&apos;, &apos;rb&apos;).read() # u = b&apos;A\xc3\x84B\xc3\xa8C&apos; len(u) = 7 #文件输入编码 s = open(&apos;latindata&apos;, &apos;r&apos;, encoding = &apos;latin-1&apos;).read() # s = &apos;A?BèC&apos; len(s) = 5 s = open(&apos;latindata&apos;, &apos;rb&apos;).read().decode(&apos;latin-1&apos;) # s = &apos;A?BèC&apos; len(s) = 5 s = open(&apos;utf8data&apos;, &apos;r&apos;, encoding = &apos;utf-8&apos;).read() # s = &apos;A?BèC&apos; len(s) = 5 s = open(&apos;utf8data&apos;, &apos;rb&apos;).read().decode(&apos;utf-8&apos;) # s = &apos;A?BèC&apos; len(s) = 5]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 文件操作]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpython%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[基本的模式 模式 说明 注意事项 r 只读模式 文件必须存在 w 只写模式 文件不存在则创建文件，文件存在则清空文件内容 x 只写模式 文件不可读，文件不存在则创建，存在则报错 a 追加模式 文件不存在创建文件，文件存在则在文件末尾添加内容 带+的模式 模式 说明 r+ 读写 w+ 写读 x+ 写读 a+ 写读 带b的模式 模式 说明 rb 二进制读模式 wb 二进制写模式 xb 二进制只写模式 ab 二进制追加模式 带+带b的模式 模式 说明 rb+ 二进制读写模式 wb+ 二进制读写模式 xb+ 二进制只写模式 ab+ 二进制读写模式]]></content>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image相关]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fimage%E7%9B%B8%E5%85%B3.html</url>
    <content type="text"><![CDATA[image相关sudo apt-get install tesseract-ocr # 安装语言支持 tesseract-ocr-chi-sim PILfrom PIL import Image, ImageFilter, ImageDraw, ImageFont, ImageEnhance, ImageFilter w, h = image.size box = (p1, p2, p3, p4) image = image.crop(box) image.show() image.thumbnail((size1, size2), Image.ANTIALIAS)#压缩 image.show() image = image.rotate(jiaodu) image.show() image = image.convert(&apos;L&apos;) #灰度 image.filter(ImageFilter.DETAIL)#过滤 draw = ImageDraw.Draw(image)#写字 draw.text((p1, p2), text) image.show() im.resize((128, 128))#resize im.rotate(45) #45度 顺时针 im.transpose(Image.ROTATE_90)# 旋转90度 image = image.convert(&apos;1&apos;) image = image.convert(&apos;P&apos;) # 虚化 image = image.convert(&apos;LA&apos;)#怀旧 def 图片拼接(image1, image2): images = (image1, image2) w, h = image1.size target = Image.new(&apos;RGB&apos;, (w * 2, h)) left = 0 right = w for image in images: temp = image.resize((w, h), Image.ANTIALIAS) target.paste(temp, (left, 0, right, h)) left += w right += w target.show() def 图片锐化(image, qiangdu): enhancer = ImageEnhance.Sharpness(image) enhancer.enhance(qiangdu).show() def 图片色彩增强(image, qiangdu): enhancer = ImageEnhance.Color(image) enhancer.enhance(qiangdu).show() def 图片亮度增强(image, qiangdu): enhancer = ImageEnhance.Brightness(image) enhancer.enhance(qiangdu).show() def 图片对比度增强(image, qiangdu): enhancer = ImageEnhance.Contrast(image) enhancer.enhance(qiangdu).show() def 图片BlUR(image): image = image.filter(ImageFilter.BLUR) image.show() def 图片MinFilter(image): image = image.filter(ImageFilter.MinFilter) image.show() def 图片转换黑白线条(image): image = image.filter(ImageFilter.CONTOUR) image.show() def 图片EMBOSS(image): image = image.filter(ImageFilter.EMBOSS) image.show() def 图片FIND_EDGES(image): image = image.filter(ImageFilter.FIND_EDGES) image.show() 验证码生成from captcha.image import ImageCaptcha number = &apos;0123456789&apos; alphabet = &apos;abcdefghijklmnopqrstuvwxyz&apos; char_set = number # +alphabet+alphabet.upper() # 生成字符对应的验证码 def gen_captcha_text_and_image(): image = ImageCaptcha() captcha_text = [random.choice(char_set)for i in range(4)] captcha_text = &apos;&apos;.join(captcha_text) captcha = image.generate(captcha_text) captcha_image = Image.open(captcha) captcha_image = captcha_image.convert(&apos;L&apos;) captcha_image = captcha_image.resize([128, 64]) captcha_image = np.array(captcha_image)/255.0 return captcha_text, captcha_image 验证码from pyocr import pyocr tools = pyocr.get_available_tools()[:] tools[0].get_name() tools[0].image_to_string(im, lang=&apos;eng&apos;) tools[0].image_to_string(im, lang=&apos;chi_sim&apos;) import requests import pytesseract as ocr from PIL import Image from io import BytesIO def retrive_img(url): resp = requests.get(url) img_fp = BytesIO(resp.content) return Image.open(img_fp) def process_img(img, threshold=140): # 灰度转换 img = img.convert(&apos;L&apos;) # 二值化 pixels = img.load() for x in range(img.width): for y in range(img.height): pixels[x,y] = 255 if pixels[x,y] &gt; threshold else 0 return img def recognize(img, lang=&apos;eng&apos;): return ocr.image_to_string(img, lang) if __name__ == &apos;__main__&apos;: img = process_img(retrive_img(&apos;http://zfcg.fjqz.gov.cn/ucapqzzfcg/portal/validate/img2.jsp&apos;)) print(recognize(img)) img.show()]]></content>
      <tags>
        <tag>验证码,PIL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 各种库和其他]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Fpython%20%E5%90%84%E7%A7%8D%E5%BA%93%E5%92%8C%E5%85%B6%E4%BB%96.html</url>
    <content type="text"><![CDATA[python 各种库和其他sys当前目录1sys.path[0] 断言assert &apos;wor&apos; in demo_str assert demo_str.startswith(&apos;hello&apos;) assert hasattr(demo_str, &apos;__sizeof__&apos;) assert 4 == 4.0 assert 5 &gt; 4 assert re.match(&apos;hello \d+&apos;, &apos;hello 9527&apos;) assert &apos;x&apos; in json.loads(&apos;{&quot;x&quot;:1, &quot;y&quot;:2}&apos;) assert True randomrandom.sample([&quot;I&quot;, &quot;love&quot;, 3, &quot;python&quot;, 66], 4) a = [3, 4, 5, 6] random.shuffle(a) random.randrange(0, 101, 2) # 偶数 random.randint(3, 8) random.uniform(4, 8) random.random() # 0-1 random.choice() pypinyinimport pinyin pinyin.get(&apos;你 好&apos;) pinyin.get(&apos;你好&apos;, format=&quot;strip&quot;, delimiter=&quot; &quot;) pinyin.get(&apos;你好&apos;, format=&quot;numerical&quot;) pinyin.get_initial(&apos;你好&apos;) from pypinyin import pinyin, lazy_pinyin import pypinyin pinyin(&apos;qianxinan&apos;, style=pypinyin.FIRST_LETTER) pinyin(&apos;中心&apos;) [[&apos;zhōng&apos;], [&apos;xīn&apos;]] pinyin(&apos;中心&apos;, heteronym=True) # 启用多音字模式 [[&apos;zhōng&apos;, &apos;zhòng&apos;], [&apos;xīn&apos;]] pinyin(&apos;中心&apos;, style=pypinyin.FIRST_LETTER) # 设置拼音风格 [[&apos;z&apos;], [&apos;x&apos;]] pinyin(&apos;中心&apos;, style=pypinyin.TONE2, heteronym=True) [[&apos;zho1ng&apos;, &apos;zho4ng&apos;], [&apos;xi1n&apos;]] lazy_pinyin(&apos;中心&apos;) # 不考虑多音字的情况 [&apos;zhong&apos;, &apos;xin&apos;] lazy_pinyin(&apos;你好☆☆&apos;, errors=&apos;ignore&apos;) [&apos;ni&apos;, &apos;hao&apos;] lazy_pinyin(&apos;你好☆☆&apos;, errors=lambda x: &apos;star&apos;) [&apos;ni&apos;, &apos;hao&apos;, &apos;star&apos;] # 自定义 from pypinyin import lazy_pinyin, load_phrases_dict, TONE2 hans = &apos;桔子&apos; lazy_pinyin(hans, style=TONE2) load_phrases_dict({&apos;桔子&apos;: [[&apos;jú&apos;], [&apos;zǐ&apos;]]}) lazy_pinyin(hans, style=TONE2) operatora + b add(a, b) a - b sub(a, b) a * b mul(a, b) a / b truediv(a, b) a // b floordiv(a, b) a ** b pow(a, b) a % b mod(a, b) a @ b matmul(a, b) - a neg(a) not a not_(a) + a pos(a) a &amp; b and_(a, b) a ^ b xor(a, b) ~ a invert(a) a | b or_(a, b) a is b is_(a, b) a is not b is_not(a, b) a &lt;&lt; b lshift(a, b) a &gt;&gt; b rshift(a, b) a &lt; b lt(a, b) a &lt;= b le(a, b) a == b eq(a, b) a != b ne(a, b) a &gt;= b ge(a, b) a &gt; b gt(a, b) pdbh(elp) 显示命令列表 help command 显示命令的说明文档 c(continue) 回复程序的执行 q(uit) 退出调试器 b(reak) number 在指定行设置断点 s(tep) 单步进入(step into)函数 n(next) 执行当前行(step over)，并进入下一行 u(p) / d(own) 在函数调用栈中向上或向下移动 a(rgs) 显示当前函数的参数 debug statement 在新的调试器中调用语句statement l(ist) statement 显示当前行，以及当前栈级别上的上下文参考代码 w(here) 打印当前位置的完整栈跟踪 ipdb-m ipdb ENTER(重复上次命令) c(继续) l(查找当前位于哪里) s(进入子程序) r(运行直到子程序结束) !&lt;python 命令 &gt; h(帮助) a(rgs) 打印当前函数的参数 j(ump) 让程序跳转到指定的行数 l(ist) 可以列出当前将要运行的代码块 n(ext) 让程序运行下一行，如果当前语句有一个函数调用，用 n 是不会进入被调用的函数体中的 p(rint) 最有用的命令之一，打印某个变量 q(uit) 退出调试 r(eturn) 继续执行，直到函数体返回 s(tep) 跟 n 相似，但是如果当前有一个函数调用，那么 s 会进入被调用的函数体中 模板编写 ${PROJECT_NAME} - 当前Project名称; ${NAME} - 在创建文件的对话框中指定的文件名; ${USER} - 当前用户名; ${DATE} - 当前系统日期; ${TIME} - 当前系统时间; ${YEAR} - 年; ${MONTH} - 月; ${DAY} - 日; ${HOUR} - 小时; ${MINUTE} - 分钟； ${PRODUCT_NAME} - 创建文件的IDE名称; ${MONTH_NAME_SHORT} - 英文月份缩写, 如: Jan, Feb, etc; ${MONTH_NAME_FULL} - 英文月份全称, 如: January, February, etc； # -*- coding: utf-8 -*- &quot;&quot;&quot; ------------------------------------------------- File Name： ${NAME} Description : Author : ${USER} date： ${DATE} ------------------------------------------------- Change Activity: ${DATE}: ------------------------------------------------- &quot;&quot;&quot; __author__ = &apos;${USER}&apos; python执行命令os.system(&quot;命令加参数&quot;) stream = os.popen(&quot;命令和参数&quot;) subprocess模块的管道Popen. subprocess.Popen(&quot;echo Hello World&quot;,shell=True,stdout=PIPE).stdout.read() os.popen(&quot;echo Hello World&quot;).read() subprocess.call(&quot;echo Hello World&quot;, shell=True) subprocess.check_call([&quot;ls&quot;, &quot;-l&quot;]) # shell = True 必须为字符串 shell = False 必须为序列 # check_output 返回命令的执行结果 # check_all 如果结果为0则返回0 如果命令执行出错则抛出异常 # 执行python命令，进入python解释器，stdin标准输入、stdout标准输出、stderr错误输出，universal_newlines=True自动输入换行符 obj = subprocess.Popen([&quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) csvimport csv import datetime # 数据 data = [ [1, &quot;a,bc&quot;, 19.353, datetime.datetime(2001, 3, 17)], [2, &quot;ei,f&quot;, 13.287, datetime.datetime(2011, 4, 27)], [3, &quot;q\&quot;ij&quot;, 15.852, datetime.datetime(2003, 7, 14)], [4, &quot;zh&apos;n&quot;, 11.937, datetime.datetime(2012, 1, 9)], [5, &quot;i\&apos;op&quot;, 12.057, datetime.datetime(2009, 5, 18)], ] # 写文件 with open(&quot;test.csv&quot;, &quot;w&quot;) as file: writer = csv.writer(file, dialect=&quot;excel&quot;) # writer.writerows(data) for item in data: writer.writerow(item) # 读文件 with open(&quot;test.csv&quot;, &quot;r&quot;) as file: reader = csv.reader(file, dialect=&quot;excel&quot;) for item in reader: print(item) # 读文件 with open(&quot;test.csv&quot;, &quot;r&quot;) as file: reader = csv.DictReader(file, fieldnames=[&quot;id&quot;, &quot;name&quot;, &quot;float&quot;, &quot;datetime&quot;], dialect=&quot;excel&quot;) data = [item for item in reader] print(data) # 写文件 with open(&quot;test.csv&quot;, &quot;w&quot;) as file: writer = csv.DictWriter(file, fieldnames=[&quot;id&quot;, &quot;name&quot;, &quot;float&quot;, &quot;datetime&quot;], dialect=&quot;excel&quot;) writer.writeheader() for item in data: writer.writerow(item) itertoolsimport itertools for i in itertools.count(10,2): #开始，步数 print(i) if i&gt;100: break for i,j in enumerate(itertools.cycle(&apos;Abc&apos;)): print(j) if i&gt;16: break for item in itertools.repeat(&apos;hi&apos;,5): print(item) num=itertools.chain([3,4],(5,6),{3,4},[3,[5,9]])#可迭代连接 list(itertools.compress(&apos;abcdef&apos;,[0,1,0,0,0,0]))# b from itertools import dropwhile list(dropwhile(lambda x:x&lt;5,[2,3,4,5,7,2,3])) #返回 不满足的至最后 from itertools import takewhile list(takewhile(lambda x:x&lt;5,[2,3,4,5,7,2,3])) #返回 0:满足 from itertools import filterfalse list(filterfalse(lambda x:x&lt;5,[2,3,4,5,7,2,3])) # 返回不满足的 from itertools import groupby for i,j in groupby(&apos;abdcdfffggeehhhaa&apos;): print(i,&apos;:&apos;,list(j)) data=[&apos;a&apos;,&apos;bb&apos;,&apos;ccc&apos;,&apos;dd&apos;,&apos;ee&apos;,&apos;f&apos;] for i,j in groupby(data,len): print(i,&apos;:&apos;,list(j)) from itertools import zip_longest for i in zip_longest(&apos;abcd&apos;,&apos;xy&apos;,fillvalue=&apos;--&apos;): print(i) for item in itertools.product(&apos;abcd&apos;,&apos;xy&apos;): print(item) list(itertools.product(&apos;xy&apos;,&apos;12&apos;,&apos;ab&apos;)) from itertools import permutations list(&apos;&apos;.join(i)for i in permutations(&apos;abcd&apos;,4)) collectionsnametuplefrom collections import namedtuple websites = [ (&apos;Sohu&apos;, &apos;http://www.google.com/&apos;, u&apos;张朝阳&apos;), (&apos;Sina&apos;, &apos;http://www.sina.com.cn/&apos;, u&apos;王志东&apos;), (&apos;163&apos;, &apos;http://www.163.com/&apos;, u&apos;丁磊&apos;) ] Website = namedtuple(&apos;Website&apos;, [&apos;name&apos;, &apos;url&apos;, &apos;founder&apos;]) for website in websites: website = Website._make(website) print (website) dequefrom collections import deque q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) appendleft()和popleft() defaultdictfrom collections import defaultdict colours = ( (&apos;Yasoob&apos;, &apos;Yellow&apos;), (&apos;Ali&apos;, &apos;Blue&apos;), (&apos;Arham&apos;, &apos;Green&apos;), (&apos;Ali&apos;, &apos;Black&apos;), (&apos;Yasoob&apos;, &apos;Red&apos;), (&apos;Ahmed&apos;, &apos;Silver&apos;), ) favourite_colours = defaultdict(list) for name, colour in colours: favourite_colours[name].append(colour) print(favourite_colours) tree = lambda: defaultdict(tree) some_dict = tree() some_dict[&apos;colours&apos;][&apos;favourite&apos;] = &quot;yellow&quot; import json print(json.dumps(some_dict)) print(json.dumps(favourite_colours)) OrderedDictfrom collections import OrderedDict colours = OrderedDict([(&quot;Red&quot;, 198), (&quot;Green&quot;, 170), (&quot;Blue&quot;, 160)]) for key, value in colours.items(): print(key, value) Counterfrom collections import Counter colours = ( (&apos;Yasoob&apos;, &apos;Yellow&apos;), (&apos;Ali&apos;, &apos;Blue&apos;), (&apos;Arham&apos;, &apos;Green&apos;), (&apos;Ali&apos;, &apos;Black&apos;), (&apos;Yasoob&apos;, &apos;Red&apos;), (&apos;Ahmed&apos;, &apos;Silver&apos;), ) favs = Counter(name for name, colour in colours) print(favs) with open(&apos;filename&apos;, &apos;rb&apos;) as f: line_count = Counter(f) print(line_count) word_counts = Counter() with open(&apos;&apos;) as f: for line in f: word_counts.update(line.strip().split(&apos;:&apos;)) for key, val in (word_counts.most_common(3)): print(key, &apos;:&apos;, val) pyinstaller 转exe12pip install pyinstallerpyinstaller yourprogram.py heapq 最大3个 最小3个12345678910portfolio = [ &#123;&apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 91.1&#125;, &#123;&apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 50, &apos;price&apos;: 543.22&#125;, &#123;&apos;name&apos;: &apos;FB&apos;, &apos;shares&apos;: 200, &apos;price&apos;: 21.09&#125;, &#123;&apos;name&apos;: &apos;HPQ&apos;, &apos;shares&apos;: 35, &apos;price&apos;: 31.75&#125;, &#123;&apos;name&apos;: &apos;YHOO&apos;, &apos;shares&apos;: 45, &apos;price&apos;: 16.35&#125;, &#123;&apos;name&apos;: &apos;ACME&apos;, &apos;shares&apos;: 75, &apos;price&apos;: 115.65&#125;]cheap = heapq.nsmallest(3, portfolio, key=lambda s: s[&apos;price&apos;])expensive = heapq.nlargest(3, portfolio, key=lambda s: s[&apos;price&apos;]) url操作 furl123456789101112131415161718192021from furl import furlf = furl(&apos;http://www.google.com/?one=1&amp;two=2&apos;)f.args[&apos;three&apos;] = &apos;3&apos;del f.args[&apos;one&apos;]f.url&apos;http://www.google.com/?two=2&amp;three=3&apos;f = furl(&apos;http://www.google.com/&apos;)f.fragment.path.segments = [&apos;two&apos;, &apos;directories&apos;]f.fragment.args = &#123;&apos;one&apos;:&apos;argument&apos;&#125;f.url&apos;http://www.google.com/#two/directories?one=argument&apos;f = furl(&apos;http://www.google.com/&apos;)f.path = &apos;some encoding here&apos;f.args[&apos;and some encoding&apos;] = &apos;here, too&apos;f.url&apos;http://www.google.com/some%20encoding%20here?and+some+encoding=here,+too&apos;f.set(host=u&apos;ドメイン.テスト&apos;, path=u&apos;джк&apos;, query=u&apos;☃=☺&apos;)f.url&apos;http://xn--eckwd4c7c.xn--zckzah/%D0%B4%D0%B6%D0%BA?%E2%98%83=%E2%98%BA&apos; 清理123import bleachbleach.clean(&apos;an &lt;script&gt;evil()&lt;/script&gt; example&apos;)bleach.linkify(&apos;an http://example.com url&apos;) 时间解析12from dateparser import parseparse(&apos;2016-4&apos;) 字符相似12345678910111213from fuzzywuzzy import fuzzfrom fuzzywuzzy import processfuzz.ratio(&quot;this is a test&quot;, &quot;this is a test!&quot;)fuzz.partial_ratio(&quot;this is a test&quot;, &quot;this is a test!&quot;)fuzz.ratio(&quot;fuzzy wuzzy was a bear&quot;, &quot;wuzzy fuzzy was a bear&quot;)fuzz.token_sort_ratio(&quot;fuzzy wuzzy was a bear&quot;, &quot;wuzzy fuzzy was a bear&quot;)fuzz.token_sort_ratio(&quot;fuzzy was a bear&quot;, &quot;fuzzy fuzzy was a bear&quot;)fuzz.token_set_ratio(&quot;fuzzy was a bear&quot;, &quot;fuzzy fuzzy was a bear&quot;)choices = [&quot;Atlanta Falcons&quot;, &quot;New York Jets&quot;, &quot;New York Giants&quot;, &quot;Dallas Cowboys&quot;]process.extract(&quot;new york jets&quot;, choices, limit=2) [(&apos;New York Jets&apos;, 100), (&apos;New York Giants&apos;, 78)]process.extractOne(&quot;cowboys&quot;, choices) (&quot;Dallas Cowboys&quot;, 90) 名字1234567from nameparser import HumanNamename = HumanName(&quot;Dr. Juan Q. Xavier de la Vega III (Doc Vega)&quot;)name.lastname.as_dict()str(name)name.string_format = &quot;&#123;first&#125; &#123;last&#125;&quot;str(name)]]></content>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests]]></title>
    <url>%2F2017%2F10%2F23%2Fpython%2Frequests.html</url>
    <content type="text"><![CDATA[requestsimport requests.adapters # 不同方式获取网页内容, 返回一个Response对象, 请求的参数可以为url或Request对象 r0 = requests.get(&quot;https://github.com/timeline.json&quot;) r1 = requests.post(&quot;http://httpbin.org/post&quot;) r2 = requests.put(&quot;http://httpbin.org/put&quot;) r3 = requests.delete(&quot;http://httpbin.org/delete&quot;) r4 = requests.head(&quot;http://httpbin.org/get&quot;) r5 = requests.options(&quot;http://httpbin.org/get&quot;) r6 = requests.patch(&quot;http://httpbin.org/get&quot;) # Request对象: # class requests.Request(method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None) # 上边所有的获取方式都调用底层的request方法, 所以request方法有的参数, 上边几个函数都应该有: # requests.request(method, url, **kwargs) # kwargs包括: params / data / json / headers / cookies / files / auth / timeout / allow_redirects(bool) / proxies / verify(bool) / stream / cert # Response对象: class requests.Response # 包含的主要属性: content / cookies / encoding / headers / history / is_permanent_redirect / is_redirect / reason / status_code / text / url 等 # 包含的主要方法: iter_content(chunk_size=1, decode_unicode=False) / iter_lines(chunk_size=512, decode_unicode=None, delimiter=None) # 包含的主要方法: close() / json(**kwargs) / raise_for_status() 等 # 以字典的形式传递URL参数, 也可以直接以?xx=xx&amp;xx=xx的形式将其放在url后 params = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;} r = requests.get(&quot;http://httpbin.org/get&quot;, params=params) print(r.url) # http://httpbin.org/get?key2=value2&amp;key1=value1 # 以字典的形式传递URL参数: 字典里带有列表 params = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: [&quot;value2&quot;, &quot;value3&quot;]} r = requests.get(&quot;http://httpbin.org/get&quot;, params=params) print(r.url) # http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3 # 获取网页内容 r = requests.get(&quot;https://github.com/timeline.json&quot;) print(r.text) # 返回正常的网页内容, 即解压解码之后的内容 print(r.content) # 返回byte类型的网页内容, 即值解压, 没有解码 print(r.json()) # 如果网页内容为json, 直接返回一个json对象 print(r.encoding) # 返回网页的编码: &quot;utf-8&quot; # Requests会自动解码来自服务器的内容, 也可以自己更改 r.encoding = &quot;ISO-8859-1&quot; print(r.text) # 此时使用新的r.encoding解码后的新值 # 编码的其他操作 # requests.utils.get_encodings_from_content(content): Returns encodings from given content string. # requests.utils.get_encoding_from_headers(headers): Returns encodings from given HTTP Header Dict. # requests.utils.get_unicode_from_response(r): Returns the requested content back in unicode. # 原始响应内容: 获取来自服务器的原始套接字响应 r = requests.get(&quot;https://github.com/timeline.json&quot;, stream=True) print(r.raw) # &lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt; print(r.raw.read(10)) # &quot;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03&quot; # 一般情况下, 应该以下面的模式将文本流保存到文件 with open(&quot;test&quot;, &quot;wb&quot;) as fd: for chunk in r.iter_content(chunk_size=256): fd.write(chunk) # 注意: 设置的timeout对connect和read起作用. 但一旦和服务器建立连接, r.content或r.iter_content就处于一个read的状态, 不受timeout影响 # 定制请求头: 一个字典 headers = {&quot;user-agent&quot;: &quot;my-app/0.0.1&quot;} r = requests.get(&quot;https://api.github.com/some/endpoint&quot;, headers=headers) print(r.request.headers) # 获取request的头部 print(r.headers) # 获取response的头部 # { # &quot;content-encoding&quot;: &quot;gzip&quot;, # &quot;transfer-encoding&quot;: &quot;chunked&quot;, # &quot;connection&quot;: &quot;close&quot;, # &quot;server&quot;: &quot;nginx/1.0.4&quot;, # &quot;x-runtime&quot;: &quot;148ms&quot;, # &quot;etag&quot;: &quot;e1ca502697e5c9317743dc078f67693f&quot;, # &quot;content-type&quot;: &quot;application/json&quot; # } print(r.headers[&quot;Content-Type&quot;]) # &quot;application/json&quot; print(r.headers.get(&quot;content-type&quot;)) # &quot;application/json&quot; # 更加复杂的POST请求: 表单 post_dict = {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;} r = requests.post(&quot;http://httpbin.org/post&quot;, data=post_dict) print(r.text) # POST一个多部分编码(Multipart-Encoded)的文件 files = {&quot;file&quot;: open(&quot;report.xls&quot;, &quot;rb&quot;)} r = requests.post(&quot;http://httpbin.org/post&quot;, files=files) print(r.text) # 你可以显式地设置文件名, 文件类型和请求头 files = {&quot;file&quot;: (&quot;report.xls&quot;, open(&quot;report.xls&quot;, &quot;rb&quot;), &quot;application/vnd.ms-excel&quot;, {&quot;Expires&quot;: &quot;0&quot;})} r = requests.post(&quot;http://httpbin.org/post&quot;, files=files) print(r.text) # 你也可以发送文本字符串 files = {&quot;file&quot;: (&quot;report.csv&quot;, &quot;some,data,to,send\nanother,row,to,send\n&quot;)} r = requests.post(&quot;http://httpbin.org/post&quot;, files=files) print(r.text) # 响应状态码 r = requests.get(&quot;http://httpbin.org/get&quot;) print(r.status_code) # 200 print(r.status_code == requests.codes.ok) # True 响应状态码查询 # 如果发送了一个错误请求(4XX客户端错误, 或5XX服务器错误响应), 可以通过 Response.raise_for_status() 来抛出异常: bad_r = requests.get(&quot;http://httpbin.org/status/404&quot;) print(bad_r.status_code) # 404 bad_r.raise_for_status() # 引发异常 # Cookie: 如果某个响应中包含一些cookie, 则会被放到response.cookies(CookieJar类型)中 r = requests.get(&quot;http://example.com/some/cookie/setting/url&quot;) print(r.cookies[&quot;example_cookie_name&quot;]) # &quot;example_cookie_value&quot; # 要想发送你的cookies到服务器, 可以使用cookies参数(一个字典) cookies = dict(cookies_are=&quot;working&quot;) r = requests.get(&quot;http://httpbin.org/cookies&quot;, cookies=cookies) print(r.text) # cookie的其他操作 # requests.utils.dict_from_cookiejar(cj): Returns a key/value dictionary from a CookieJar. # requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True): Returns a CookieJar from a key/value dictionary. # requests.utils.add_dict_to_cookiejar(cj, cookie_dict): Returns a CookieJar from a key/value dictionary. # 通用CookieJar类, 一个cookielib.CookieJar, 但是提供一个dict接口 # class requests.cookies.RequestsCookieJar(policy=None): Compatibility class; is a cookielib.CookieJar, but exposes a dict interface. # 会话对象: 会话对象让你能够跨请求保持某些参数, 它也会在同一个Session实例发出的所有请求之间保持cookie s = requests.Session() s.get(&quot;http://httpbin.org/cookies/set/sessioncookie/123456789&quot;) s.get(&quot;http://httpbin.org/cookies&quot;) for cookie in s.cookies: print(cookie) # 如果你要手动为会话添加cookie, 就是用Cookie utility函数来操纵Session.cookies requests.utils.add_dict_to_cookiejar(s.cookies, {&quot;cookie_key&quot;: &quot;cookie_value&quot;}) # 会话也可用来为请求方法提供缺省数据, 这是通过为会话对象的属性提供数据来实现的 s.auth = (&quot;user&quot;, &quot;pass&quot;) s.headers.update({&quot;x-test&quot;: &quot;true&quot;}) s.get(&quot;http://httpbin.org/headers&quot;, headers={&quot;x-test2&quot;: &quot;true&quot;}) # both &quot;x-test&quot; and &quot;x-test2&quot; are sent # 不过需要注意, 就算使用了会话, 方法级别的参数也不会被跨请求保持, 下面的例子只会给第一个请求发送cookie s.get(&quot;http://httpbin.org/cookies&quot;, cookies={&quot;from-my&quot;: &quot;browser&quot;}) # 带有cookie s.get(&quot;http://httpbin.org/cookies&quot;) # 不带cookie # 会话还可以用作前后文管理器 with requests.Session() as s: s.get(&quot;http://httpbin.org/cookies/set/sessioncookie/123456789&quot;) # class requests.Session类, 和requests外层有的函数/属性基本一致, 只不过是封装了一层跨域请求的功能 # 重定向与请求历史, 默认情况下, 除了HEAD, Requests会自动处理所有重定向, 可以通过allow_redirects参数禁用重定向处理 # 可以使用响应对象的history方法来追踪重定向, Response.history 是一个Response对象的列表, 按照从最老到最近的请求进行排序 r = requests.get(&quot;http://github.com&quot;, allow_redirects=True) print(r.status_code) # 200 print(r.history) # [&lt;Response [301]&gt;] r = requests.get(&quot;http://github.com&quot;, allow_redirects=False) print(r.status_code) # 301 print(r.history) # [] # 超时, 设置timeout参数 requests.get(&quot;http://github.com&quot;, timeout=0.001) # Traceback (most recent call last): # File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; # requests.exceptions.Timeout: HTTPConnectionPool(host=&quot;github.com&quot;, port=80): Request timed out. (timeout=0.001) # 注意: timeout仅对连接过程有效, 与响应体的下载无关 # timeout并不是整个下载响应的时间限制, 而是如果服务器在timeout秒内没有应答, 将会引发一个异常 # 更精确地说, 是在timeout秒内没有从基础套接字上接收到任何字节的数据时 requests.get(&quot;https://github.com&quot;, timeout=5) # 上边的timeout值将会用作 connect 和 read 二者的timeout, 如果要分别制定, 就传入一个元组 requests.get(&quot;https://github.com&quot;, timeout=(3.05, 27)) # 错误与异常: 遇到网络问题(如: DNS 查询失败、拒绝连接等)时, Requests 会抛出一个 ConnectionError 异常 # 如果 HTTP 请求返回了不成功的状态码, Response.raise_for_status() 会抛出一个 HTTPError 异常 # 若请求超时, 则抛出一个 Timeout 异常 # 若请求超过了设定的最大重定向次数, 则会抛出一个 TooManyRedirects 异常 # 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException # 所有异常: # exception requests.RequestException(*args, **kwargs): There was an ambiguous exception that occurred while handling your request. # exception requests.ConnectionError(*args, **kwargs): A Connection error occurred. # exception requests.HTTPError(*args, **kwargs): An HTTP error occurred. # exception requests.URLRequired(*args, **kwargs): A valid URL is required to make a request. # exception requests.TooManyRedirects(*args, **kwargs): Too many redirects. # exception requests.ConnectTimeout(*args, **kwargs): The request timed out while trying to connect to the remote server. # exception requests.ReadTimeout(*args, **kwargs): The server did not send any data in the allotted amount of time. # exception requests.Timeout(*args, **kwargs): The request timed out. # SSL证书验证, verify设置为True表示检查证书, 设置为False表示忽略证书 requests.get(&quot;https://kennethreitz.com&quot;, verify=True) # 未设置SSL证书, 抛出异常 # requests.exceptions.SSLError: hostname &quot;kennethreitz.com&quot; doesn&quot;t match either of &quot;*.herokuapp.com&quot;, &quot;herokuapp.com&quot; requests.get(&quot;https://github.com&quot;, verify=True) # &lt;Response [200]&gt;, 已设置SSL证书 # 对于私有证书，你也可以传递一个 CA_BUNDLE 文件的路径给 verify # 你也可以指定一个本地证书用作客户端证书, 可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组: requests.get(&quot;https://kennethreitz.com&quot;, cert=(&quot;/path/server.crt&quot;, &quot;/path/key&quot;)) requests.get(&quot;https://kennethreitz.com&quot;, cert=&quot;/wrong_path/server.pem&quot;) # SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib # 警告: 本地证书的私有 key 必须是解密状态. 目前Requests不支持使用加密的 key # 流式上传, 允许你发送大的数据流或文件而无需先把它们读入内存 with open(&quot;massive-body&quot;) as f: requests.post(&quot;http://some.url/streamed&quot;, data=f) # 事件挂钩, 可用的钩子: response(从一个请求产生的响应) # 你可以通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数为每个请求分配一个钩子函数 def print_url(resp): print(resp.url) return requests.get(&quot;http://httpbin.org&quot;, hooks=dict(response=print_url)) # 代理 proxies = { &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;, &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;, } requests.get(&quot;http://example.org&quot;, proxies=proxies) # 若代理需要使用HTTP Basic Auth, 可以使用http://user:password@host:port/, 比如&quot;http&quot;: &quot;http://user:pass@10.10.1.10:3128/&quot; # 除了基本的 HTTP 代理, Request 还支持 SOCKS 协议的代理, 此时需要单独安装: # $ pip install requests[socks] proxies = { &quot;http&quot;: &quot;socks5://user:pass@host:port&quot;, &quot;https&quot;: &quot;socks5://user:pass@host:port&quot; } requests.get(&quot;http://example.org&quot;, proxies=proxies) # Requests 传输适配器 # 从 v1.0.0 以后，Requests 的内部采用了模块化设计。部分原因是为了实现传输适配器（Transport Adapter）。 # 传输适配器提供了一个机制，让你可以为 HTTP 服务定义交互方法。尤其是它允许你应用服务前的配置。 # Requests 自带了一个传输适配器，也就是 HTTPAdapter。 这个适配器使用了强大的 urllib3，为 Requests 提供了默认的 HTTP 和 HTTPS 交互。 # 每当 Session 被初始化，就会有适配器附着在 Session 上，其中一个供 HTTP 使用，另一个供 HTTPS 使用。 # Request 允许用户创建和使用他们自己的传输适配器，实现他们需要的特殊功能。创建好以后，传输适配器可以被加载到一个会话对象上，附带着一个说明，告诉会话适配器应该应用在哪个 web 服务上。 s = requests.Session() s.mount(&quot;http://baidu.com&quot;, requests.adapters.HTTPAdapter()) # 出现错误: Connection pool is full, discarding connection: xxxx.com s.mount(&apos;https://&apos;, requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)) # 关闭InsecurePlatformWarning # requests.packages.urllib3.disable_warnings()]]></content>
      <tags>
        <tag>requests,爬虫</tag>
      </tags>
  </entry>
</search>